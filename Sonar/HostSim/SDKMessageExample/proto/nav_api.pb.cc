// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nav_api.proto

#include "nav_api.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace proto {
namespace nav_api {
constexpr RequestResult::RequestResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_detail_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , time_(nullptr)
  , code_(0)
{}
struct RequestResultDefaultTypeInternal {
  constexpr RequestResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RequestResultDefaultTypeInternal() {}
  union {
    RequestResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RequestResultDefaultTypeInternal _RequestResult_default_instance_;
constexpr HydrophoneData::HydrophoneData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : serial_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , transmit_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , time_(nullptr)
  , raw_timeseries_(nullptr)
  , num_hor_phones_(0)
  , num_ver_phones_(0){}
struct HydrophoneDataDefaultTypeInternal {
  constexpr HydrophoneDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HydrophoneDataDefaultTypeInternal() {}
  union {
    HydrophoneData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HydrophoneDataDefaultTypeInternal _HydrophoneData_default_instance_;
constexpr TargetData::TargetData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bottom_()
  , groups_()
  , serial_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , time_(nullptr)
  , heading_(nullptr)
  , position_(nullptr)
  , grid_description_(nullptr)
  , max_depth_(0)
  , max_range_index_(0){}
struct TargetDataDefaultTypeInternal {
  constexpr TargetDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TargetDataDefaultTypeInternal() {}
  union {
    TargetData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TargetDataDefaultTypeInternal _TargetData_default_instance_;
constexpr Bin::Bin(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hor_index_(0)
  , ver_index_(0)
  , range_index_(0)
  , cross_range_(0)
  , down_range_(0)
  , depth_(0)
  , strength_(0)
  , confidence_(0){}
struct BinDefaultTypeInternal {
  constexpr BinDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BinDefaultTypeInternal() {}
  union {
    Bin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BinDefaultTypeInternal _Bin_default_instance_;
constexpr Group::Group(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bins_(){}
struct GroupDefaultTypeInternal {
  constexpr GroupDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GroupDefaultTypeInternal() {}
  union {
    Group _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GroupDefaultTypeInternal _Group_default_instance_;
constexpr ProcessorSettings::ProcessorSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : time_(nullptr)
  , min_inwater_squelch_(0)
  , max_inwater_squelch_(0)
  , inwater_squelch_(0)
  , squelchless_inwater_detector_(false)
  , detect_bottom_(false)
  , system_type_(0)

  , fov_(2)
{}
struct ProcessorSettingsDefaultTypeInternal {
  constexpr ProcessorSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ProcessorSettingsDefaultTypeInternal() {}
  union {
    ProcessorSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ProcessorSettingsDefaultTypeInternal _ProcessorSettings_default_instance_;
constexpr GetProcessorSettingsRequest::GetProcessorSettingsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct GetProcessorSettingsRequestDefaultTypeInternal {
  constexpr GetProcessorSettingsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetProcessorSettingsRequestDefaultTypeInternal() {}
  union {
    GetProcessorSettingsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetProcessorSettingsRequestDefaultTypeInternal _GetProcessorSettingsRequest_default_instance_;
constexpr GetProcessorSettingsResponse::GetProcessorSettingsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(nullptr)
  , settings_(nullptr){}
struct GetProcessorSettingsResponseDefaultTypeInternal {
  constexpr GetProcessorSettingsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetProcessorSettingsResponseDefaultTypeInternal() {}
  union {
    GetProcessorSettingsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetProcessorSettingsResponseDefaultTypeInternal _GetProcessorSettingsResponse_default_instance_;
constexpr SetFieldOfViewRequest::SetFieldOfViewRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fov_(0)
{}
struct SetFieldOfViewRequestDefaultTypeInternal {
  constexpr SetFieldOfViewRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetFieldOfViewRequestDefaultTypeInternal() {}
  union {
    SetFieldOfViewRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetFieldOfViewRequestDefaultTypeInternal _SetFieldOfViewRequest_default_instance_;
constexpr SetFieldOfViewResponse::SetFieldOfViewResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(nullptr){}
struct SetFieldOfViewResponseDefaultTypeInternal {
  constexpr SetFieldOfViewResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetFieldOfViewResponseDefaultTypeInternal() {}
  union {
    SetFieldOfViewResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetFieldOfViewResponseDefaultTypeInternal _SetFieldOfViewResponse_default_instance_;
constexpr SetBottomDetectionRequest::SetBottomDetectionRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : enable_bottom_detection_(false){}
struct SetBottomDetectionRequestDefaultTypeInternal {
  constexpr SetBottomDetectionRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetBottomDetectionRequestDefaultTypeInternal() {}
  union {
    SetBottomDetectionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetBottomDetectionRequestDefaultTypeInternal _SetBottomDetectionRequest_default_instance_;
constexpr SetBottomDetectionResponse::SetBottomDetectionResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(nullptr){}
struct SetBottomDetectionResponseDefaultTypeInternal {
  constexpr SetBottomDetectionResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetBottomDetectionResponseDefaultTypeInternal() {}
  union {
    SetBottomDetectionResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetBottomDetectionResponseDefaultTypeInternal _SetBottomDetectionResponse_default_instance_;
constexpr SetInWaterSquelchRequest::SetInWaterSquelchRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : new_squelch_val_(0){}
struct SetInWaterSquelchRequestDefaultTypeInternal {
  constexpr SetInWaterSquelchRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetInWaterSquelchRequestDefaultTypeInternal() {}
  union {
    SetInWaterSquelchRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetInWaterSquelchRequestDefaultTypeInternal _SetInWaterSquelchRequest_default_instance_;
constexpr SetInWaterSquelchResponse::SetInWaterSquelchResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(nullptr){}
struct SetInWaterSquelchResponseDefaultTypeInternal {
  constexpr SetInWaterSquelchResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetInWaterSquelchResponseDefaultTypeInternal() {}
  union {
    SetInWaterSquelchResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetInWaterSquelchResponseDefaultTypeInternal _SetInWaterSquelchResponse_default_instance_;
constexpr SetSquelchlessInWaterDetectorRequest::SetSquelchlessInWaterDetectorRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : enable_squelchless_detection_(false){}
struct SetSquelchlessInWaterDetectorRequestDefaultTypeInternal {
  constexpr SetSquelchlessInWaterDetectorRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetSquelchlessInWaterDetectorRequestDefaultTypeInternal() {}
  union {
    SetSquelchlessInWaterDetectorRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetSquelchlessInWaterDetectorRequestDefaultTypeInternal _SetSquelchlessInWaterDetectorRequest_default_instance_;
constexpr SetSquelchlessInWaterDetectorResponse::SetSquelchlessInWaterDetectorResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(nullptr){}
struct SetSquelchlessInWaterDetectorResponseDefaultTypeInternal {
  constexpr SetSquelchlessInWaterDetectorResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetSquelchlessInWaterDetectorResponseDefaultTypeInternal() {}
  union {
    SetSquelchlessInWaterDetectorResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetSquelchlessInWaterDetectorResponseDefaultTypeInternal _SetSquelchlessInWaterDetectorResponse_default_instance_;
constexpr VesselInfo::VesselInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : draft_(0)
  , keel_offset_(0){}
struct VesselInfoDefaultTypeInternal {
  constexpr VesselInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VesselInfoDefaultTypeInternal() {}
  union {
    VesselInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VesselInfoDefaultTypeInternal _VesselInfo_default_instance_;
constexpr GetVesselInfoRequest::GetVesselInfoRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct GetVesselInfoRequestDefaultTypeInternal {
  constexpr GetVesselInfoRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetVesselInfoRequestDefaultTypeInternal() {}
  union {
    GetVesselInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetVesselInfoRequestDefaultTypeInternal _GetVesselInfoRequest_default_instance_;
constexpr GetVesselInfoResponse::GetVesselInfoResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(nullptr)
  , info_(nullptr){}
struct GetVesselInfoResponseDefaultTypeInternal {
  constexpr GetVesselInfoResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetVesselInfoResponseDefaultTypeInternal() {}
  union {
    GetVesselInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetVesselInfoResponseDefaultTypeInternal _GetVesselInfoResponse_default_instance_;
constexpr SetDraftRequest::SetDraftRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : new_draft_(0){}
struct SetDraftRequestDefaultTypeInternal {
  constexpr SetDraftRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetDraftRequestDefaultTypeInternal() {}
  union {
    SetDraftRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetDraftRequestDefaultTypeInternal _SetDraftRequest_default_instance_;
constexpr SetDraftResponse::SetDraftResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(nullptr){}
struct SetDraftResponseDefaultTypeInternal {
  constexpr SetDraftResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetDraftResponseDefaultTypeInternal() {}
  union {
    SetDraftResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetDraftResponseDefaultTypeInternal _SetDraftResponse_default_instance_;
constexpr SetKeelOffsetRequest::SetKeelOffsetRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : new_keel_offset_(0){}
struct SetKeelOffsetRequestDefaultTypeInternal {
  constexpr SetKeelOffsetRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetKeelOffsetRequestDefaultTypeInternal() {}
  union {
    SetKeelOffsetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetKeelOffsetRequestDefaultTypeInternal _SetKeelOffsetRequest_default_instance_;
constexpr SetKeelOffsetResponse::SetKeelOffsetResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(nullptr){}
struct SetKeelOffsetResponseDefaultTypeInternal {
  constexpr SetKeelOffsetResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SetKeelOffsetResponseDefaultTypeInternal() {}
  union {
    SetKeelOffsetResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SetKeelOffsetResponseDefaultTypeInternal _SetKeelOffsetResponse_default_instance_;
}  // namespace nav_api
}  // namespace proto
namespace proto {
namespace nav_api {
bool RequestResult_ResultCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RequestResult_ResultCode_strings[6] = {};

static const char RequestResult_ResultCode_names[] =
  "kInvalidRequest"
  "kOperationUnavailable"
  "kParameterMissing"
  "kParameterOutOfRange"
  "kSuccess"
  "kUnknownError";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RequestResult_ResultCode_entries[] = {
  { {RequestResult_ResultCode_names + 0, 15}, 5 },
  { {RequestResult_ResultCode_names + 15, 21}, 2 },
  { {RequestResult_ResultCode_names + 36, 17}, 4 },
  { {RequestResult_ResultCode_names + 53, 20}, 3 },
  { {RequestResult_ResultCode_names + 73, 8}, 0 },
  { {RequestResult_ResultCode_names + 81, 13}, 1 },
};

static const int RequestResult_ResultCode_entries_by_number[] = {
  4, // 0 -> kSuccess
  5, // 1 -> kUnknownError
  1, // 2 -> kOperationUnavailable
  3, // 3 -> kParameterOutOfRange
  2, // 4 -> kParameterMissing
  0, // 5 -> kInvalidRequest
};

const std::string& RequestResult_ResultCode_Name(
    RequestResult_ResultCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RequestResult_ResultCode_entries,
          RequestResult_ResultCode_entries_by_number,
          6, RequestResult_ResultCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RequestResult_ResultCode_entries,
      RequestResult_ResultCode_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RequestResult_ResultCode_strings[idx].get();
}
bool RequestResult_ResultCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestResult_ResultCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RequestResult_ResultCode_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<RequestResult_ResultCode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RequestResult_ResultCode RequestResult::kSuccess;
constexpr RequestResult_ResultCode RequestResult::kUnknownError;
constexpr RequestResult_ResultCode RequestResult::kOperationUnavailable;
constexpr RequestResult_ResultCode RequestResult::kParameterOutOfRange;
constexpr RequestResult_ResultCode RequestResult::kParameterMissing;
constexpr RequestResult_ResultCode RequestResult::kInvalidRequest;
constexpr RequestResult_ResultCode RequestResult::ResultCode_MIN;
constexpr RequestResult_ResultCode RequestResult::ResultCode_MAX;
constexpr int RequestResult::ResultCode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ProcessorSettings_SystemType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProcessorSettings_SystemType_strings[4] = {};

static const char ProcessorSettings_SystemType_names[] =
  "kFS1000"
  "kFS350"
  "kFS3DT"
  "kFS500";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProcessorSettings_SystemType_entries[] = {
  { {ProcessorSettings_SystemType_names + 0, 7}, 2 },
  { {ProcessorSettings_SystemType_names + 7, 6}, 3 },
  { {ProcessorSettings_SystemType_names + 13, 6}, 0 },
  { {ProcessorSettings_SystemType_names + 19, 6}, 1 },
};

static const int ProcessorSettings_SystemType_entries_by_number[] = {
  2, // 0 -> kFS3DT
  3, // 1 -> kFS500
  0, // 2 -> kFS1000
  1, // 3 -> kFS350
};

const std::string& ProcessorSettings_SystemType_Name(
    ProcessorSettings_SystemType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProcessorSettings_SystemType_entries,
          ProcessorSettings_SystemType_entries_by_number,
          4, ProcessorSettings_SystemType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProcessorSettings_SystemType_entries,
      ProcessorSettings_SystemType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProcessorSettings_SystemType_strings[idx].get();
}
bool ProcessorSettings_SystemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessorSettings_SystemType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProcessorSettings_SystemType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ProcessorSettings_SystemType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ProcessorSettings_SystemType ProcessorSettings::kFS3DT;
constexpr ProcessorSettings_SystemType ProcessorSettings::kFS500;
constexpr ProcessorSettings_SystemType ProcessorSettings::kFS1000;
constexpr ProcessorSettings_SystemType ProcessorSettings::kFS350;
constexpr ProcessorSettings_SystemType ProcessorSettings::SystemType_MIN;
constexpr ProcessorSettings_SystemType ProcessorSettings::SystemType_MAX;
constexpr int ProcessorSettings::SystemType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool FieldOfView_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FieldOfView_strings[12] = {};

static const char FieldOfView_names[] =
  "k120d100m"
  "k120d200m"
  "k60d1000m"
  "k60d440m"
  "k90d100m"
  "k90d110m"
  "k90d200m"
  "k90d220m"
  "k90d330m"
  "k90d350m"
  "k90d500m"
  "kAlt";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FieldOfView_entries[] = {
  { {FieldOfView_names + 0, 9}, 5 },
  { {FieldOfView_names + 9, 9}, 6 },
  { {FieldOfView_names + 18, 9}, 8 },
  { {FieldOfView_names + 27, 8}, 3 },
  { {FieldOfView_names + 35, 8}, 9 },
  { {FieldOfView_names + 43, 8}, 0 },
  { {FieldOfView_names + 51, 8}, 10 },
  { {FieldOfView_names + 59, 8}, 1 },
  { {FieldOfView_names + 67, 8}, 2 },
  { {FieldOfView_names + 75, 8}, 11 },
  { {FieldOfView_names + 83, 8}, 7 },
  { {FieldOfView_names + 91, 4}, 4 },
};

static const int FieldOfView_entries_by_number[] = {
  5, // 0 -> k90d110m
  7, // 1 -> k90d220m
  8, // 2 -> k90d330m
  3, // 3 -> k60d440m
  11, // 4 -> kAlt
  0, // 5 -> k120d100m
  1, // 6 -> k120d200m
  10, // 7 -> k90d500m
  2, // 8 -> k60d1000m
  4, // 9 -> k90d100m
  6, // 10 -> k90d200m
  9, // 11 -> k90d350m
};

const std::string& FieldOfView_Name(
    FieldOfView value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FieldOfView_entries,
          FieldOfView_entries_by_number,
          12, FieldOfView_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FieldOfView_entries,
      FieldOfView_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FieldOfView_strings[idx].get();
}
bool FieldOfView_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FieldOfView* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FieldOfView_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<FieldOfView>(int_value);
  }
  return success;
}

// ===================================================================

class RequestResult::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestResult>()._has_bits_);
  static const ::proto::time::Time& time(const RequestResult* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_result_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::proto::time::Time&
RequestResult::_Internal::time(const RequestResult* msg) {
  return *msg->time_;
}
void RequestResult::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
RequestResult::RequestResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.RequestResult)
}
RequestResult::RequestResult(const RequestResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  result_detail_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    result_detail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_result_detail()) {
    result_detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_result_detail(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_time()) {
    time_ = new ::proto::time::Time(*from.time_);
  } else {
    time_ = nullptr;
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.RequestResult)
}

inline void RequestResult::SharedCtor() {
result_detail_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  result_detail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&code_) -
    reinterpret_cast<char*>(&time_)) + sizeof(code_));
}

RequestResult::~RequestResult() {
  // @@protoc_insertion_point(destructor:proto.nav_api.RequestResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RequestResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  result_detail_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete time_;
}

void RequestResult::ArenaDtor(void* object) {
  RequestResult* _this = reinterpret_cast< RequestResult* >(object);
  (void)_this;
}
void RequestResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RequestResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RequestResult::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.RequestResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      result_detail_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(time_ != nullptr);
      time_->Clear();
    }
  }
  code_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RequestResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.time.Time time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .proto.nav_api.RequestResult.ResultCode code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::proto::nav_api::RequestResult_ResultCode_IsValid(val))) {
            _internal_set_code(static_cast<::proto::nav_api::RequestResult_ResultCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string result_detail = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_result_detail();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.RequestResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.time.Time time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::time(this), target, stream);
  }

  // optional .proto.nav_api.RequestResult.ResultCode code = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_code(), target);
  }

  // optional string result_detail = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_result_detail(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.RequestResult)
  return target;
}

size_t RequestResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.RequestResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string result_detail = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_result_detail());
    }

    // optional .proto.time.Time time = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *time_);
    }

    // optional .proto.nav_api.RequestResult.ResultCode code = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequestResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RequestResult*>(
      &from));
}

void RequestResult::MergeFrom(const RequestResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.RequestResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_result_detail(from._internal_result_detail());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_time()->::proto::time::Time::MergeFrom(from._internal_time());
    }
    if (cached_has_bits & 0x00000004u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RequestResult::CopyFrom(const RequestResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.RequestResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestResult::IsInitialized() const {
  return true;
}

void RequestResult::InternalSwap(RequestResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &result_detail_, lhs_arena,
      &other->result_detail_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestResult, code_)
      + sizeof(RequestResult::code_)
      - PROTOBUF_FIELD_OFFSET(RequestResult, time_)>(
          reinterpret_cast<char*>(&time_),
          reinterpret_cast<char*>(&other->time_));
}

std::string RequestResult::GetTypeName() const {
  return "proto.nav_api.RequestResult";
}


// ===================================================================

class HydrophoneData::_Internal {
 public:
  using HasBits = decltype(std::declval<HydrophoneData>()._has_bits_);
  static const ::proto::time::Time& time(const HydrophoneData* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::proto::array::ArrayData& raw_timeseries(const HydrophoneData* msg);
  static void set_has_raw_timeseries(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_hor_phones(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_ver_phones(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_transmit_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::proto::time::Time&
HydrophoneData::_Internal::time(const HydrophoneData* msg) {
  return *msg->time_;
}
const ::proto::array::ArrayData&
HydrophoneData::_Internal::raw_timeseries(const HydrophoneData* msg) {
  return *msg->raw_timeseries_;
}
void HydrophoneData::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void HydrophoneData::clear_raw_timeseries() {
  if (raw_timeseries_ != nullptr) raw_timeseries_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
HydrophoneData::HydrophoneData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.HydrophoneData)
}
HydrophoneData::HydrophoneData(const HydrophoneData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serial()) {
    serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial(), 
      GetArenaForAllocation());
  }
  transmit_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    transmit_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_transmit_id()) {
    transmit_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_transmit_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_time()) {
    time_ = new ::proto::time::Time(*from.time_);
  } else {
    time_ = nullptr;
  }
  if (from._internal_has_raw_timeseries()) {
    raw_timeseries_ = new ::proto::array::ArrayData(*from.raw_timeseries_);
  } else {
    raw_timeseries_ = nullptr;
  }
  ::memcpy(&num_hor_phones_, &from.num_hor_phones_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_ver_phones_) -
    reinterpret_cast<char*>(&num_hor_phones_)) + sizeof(num_ver_phones_));
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.HydrophoneData)
}

inline void HydrophoneData::SharedCtor() {
serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
transmit_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  transmit_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_ver_phones_) -
    reinterpret_cast<char*>(&time_)) + sizeof(num_ver_phones_));
}

HydrophoneData::~HydrophoneData() {
  // @@protoc_insertion_point(destructor:proto.nav_api.HydrophoneData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void HydrophoneData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  serial_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  transmit_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete time_;
  if (this != internal_default_instance()) delete raw_timeseries_;
}

void HydrophoneData::ArenaDtor(void* object) {
  HydrophoneData* _this = reinterpret_cast< HydrophoneData* >(object);
  (void)_this;
}
void HydrophoneData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HydrophoneData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HydrophoneData::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.HydrophoneData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      serial_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      transmit_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(time_ != nullptr);
      time_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(raw_timeseries_ != nullptr);
      raw_timeseries_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&num_hor_phones_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_ver_phones_) -
        reinterpret_cast<char*>(&num_hor_phones_)) + sizeof(num_ver_phones_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HydrophoneData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.time.Time time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .proto.array.ArrayData raw_timeseries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_timeseries(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_hor_phones = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_hor_phones(&has_bits);
          num_hor_phones_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_ver_phones = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_ver_phones(&has_bits);
          num_ver_phones_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string serial = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_serial();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string transmit_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_transmit_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HydrophoneData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.HydrophoneData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.time.Time time = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::time(this), target, stream);
  }

  // optional .proto.array.ArrayData raw_timeseries = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::raw_timeseries(this), target, stream);
  }

  // optional int32 num_hor_phones = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_hor_phones(), target);
  }

  // optional int32 num_ver_phones = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_num_ver_phones(), target);
  }

  // optional string serial = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_serial(), target);
  }

  // optional string transmit_id = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_transmit_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.HydrophoneData)
  return target;
}

size_t HydrophoneData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.HydrophoneData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string serial = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial());
    }

    // optional string transmit_id = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_transmit_id());
    }

    // optional .proto.time.Time time = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *time_);
    }

    // optional .proto.array.ArrayData raw_timeseries = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *raw_timeseries_);
    }

    // optional int32 num_hor_phones = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_num_hor_phones());
    }

    // optional int32 num_ver_phones = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_num_ver_phones());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HydrophoneData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HydrophoneData*>(
      &from));
}

void HydrophoneData::MergeFrom(const HydrophoneData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.HydrophoneData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_serial(from._internal_serial());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_transmit_id(from._internal_transmit_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_time()->::proto::time::Time::MergeFrom(from._internal_time());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_raw_timeseries()->::proto::array::ArrayData::MergeFrom(from._internal_raw_timeseries());
    }
    if (cached_has_bits & 0x00000010u) {
      num_hor_phones_ = from.num_hor_phones_;
    }
    if (cached_has_bits & 0x00000020u) {
      num_ver_phones_ = from.num_ver_phones_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HydrophoneData::CopyFrom(const HydrophoneData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.HydrophoneData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HydrophoneData::IsInitialized() const {
  return true;
}

void HydrophoneData::InternalSwap(HydrophoneData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_, lhs_arena,
      &other->serial_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &transmit_id_, lhs_arena,
      &other->transmit_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HydrophoneData, num_ver_phones_)
      + sizeof(HydrophoneData::num_ver_phones_)
      - PROTOBUF_FIELD_OFFSET(HydrophoneData, time_)>(
          reinterpret_cast<char*>(&time_),
          reinterpret_cast<char*>(&other->time_));
}

std::string HydrophoneData::GetTypeName() const {
  return "proto.nav_api.HydrophoneData";
}


// ===================================================================

class TargetData::_Internal {
 public:
  using HasBits = decltype(std::declval<TargetData>()._has_bits_);
  static const ::proto::time::Time& time(const TargetData* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::proto::nav_info::Heading& heading(const TargetData* msg);
  static void set_has_heading(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::proto::nav_info::Position& position(const TargetData* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::proto::grid_description::GridDescription& grid_description(const TargetData* msg);
  static void set_has_grid_description(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_range_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::proto::time::Time&
TargetData::_Internal::time(const TargetData* msg) {
  return *msg->time_;
}
const ::proto::nav_info::Heading&
TargetData::_Internal::heading(const TargetData* msg) {
  return *msg->heading_;
}
const ::proto::nav_info::Position&
TargetData::_Internal::position(const TargetData* msg) {
  return *msg->position_;
}
const ::proto::grid_description::GridDescription&
TargetData::_Internal::grid_description(const TargetData* msg) {
  return *msg->grid_description_;
}
void TargetData::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void TargetData::clear_heading() {
  if (heading_ != nullptr) heading_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void TargetData::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void TargetData::clear_grid_description() {
  if (grid_description_ != nullptr) grid_description_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
TargetData::TargetData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  bottom_(arena),
  groups_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.TargetData)
}
TargetData::TargetData(const TargetData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      bottom_(from.bottom_),
      groups_(from.groups_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serial()) {
    serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_time()) {
    time_ = new ::proto::time::Time(*from.time_);
  } else {
    time_ = nullptr;
  }
  if (from._internal_has_heading()) {
    heading_ = new ::proto::nav_info::Heading(*from.heading_);
  } else {
    heading_ = nullptr;
  }
  if (from._internal_has_position()) {
    position_ = new ::proto::nav_info::Position(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_grid_description()) {
    grid_description_ = new ::proto::grid_description::GridDescription(*from.grid_description_);
  } else {
    grid_description_ = nullptr;
  }
  ::memcpy(&max_depth_, &from.max_depth_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_range_index_) -
    reinterpret_cast<char*>(&max_depth_)) + sizeof(max_range_index_));
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.TargetData)
}

inline void TargetData::SharedCtor() {
serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_range_index_) -
    reinterpret_cast<char*>(&time_)) + sizeof(max_range_index_));
}

TargetData::~TargetData() {
  // @@protoc_insertion_point(destructor:proto.nav_api.TargetData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TargetData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  serial_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete time_;
  if (this != internal_default_instance()) delete heading_;
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete grid_description_;
}

void TargetData::ArenaDtor(void* object) {
  TargetData* _this = reinterpret_cast< TargetData* >(object);
  (void)_this;
}
void TargetData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TargetData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TargetData::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.TargetData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bottom_.Clear();
  groups_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      serial_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(time_ != nullptr);
      time_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(heading_ != nullptr);
      heading_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(position_ != nullptr);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(grid_description_ != nullptr);
      grid_description_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&max_depth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_range_index_) -
        reinterpret_cast<char*>(&max_depth_)) + sizeof(max_range_index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TargetData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.time.Time time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string serial = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_serial();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .proto.nav_info.Heading heading = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_heading(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .proto.nav_info.Position position = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.nav_api.Bin bottom = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bottom(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.nav_api.Group groups = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .proto.grid_description.GridDescription grid_description = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_grid_description(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double max_depth = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_max_depth(&has_bits);
          max_depth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_range_index = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_max_range_index(&has_bits);
          max_range_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TargetData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.TargetData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.time.Time time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::time(this), target, stream);
  }

  // optional string serial = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_serial(), target);
  }

  // optional .proto.nav_info.Heading heading = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::heading(this), target, stream);
  }

  // optional .proto.nav_info.Position position = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::position(this), target, stream);
  }

  // repeated .proto.nav_api.Bin bottom = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_bottom_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_bottom(i), target, stream);
  }

  // repeated .proto.nav_api.Group groups = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_groups_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_groups(i), target, stream);
  }

  // optional .proto.grid_description.GridDescription grid_description = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::grid_description(this), target, stream);
  }

  // optional double max_depth = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_max_depth(), target);
  }

  // optional int32 max_range_index = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_max_range_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.TargetData)
  return target;
}

size_t TargetData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.TargetData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.nav_api.Bin bottom = 6;
  total_size += 1UL * this->_internal_bottom_size();
  for (const auto& msg : this->bottom_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .proto.nav_api.Group groups = 7;
  total_size += 1UL * this->_internal_groups_size();
  for (const auto& msg : this->groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string serial = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial());
    }

    // optional .proto.time.Time time = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *time_);
    }

    // optional .proto.nav_info.Heading heading = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *heading_);
    }

    // optional .proto.nav_info.Position position = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .proto.grid_description.GridDescription grid_description = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *grid_description_);
    }

    // optional double max_depth = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional int32 max_range_index = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_range_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TargetData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TargetData*>(
      &from));
}

void TargetData::MergeFrom(const TargetData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.TargetData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  bottom_.MergeFrom(from.bottom_);
  groups_.MergeFrom(from.groups_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_serial(from._internal_serial());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_time()->::proto::time::Time::MergeFrom(from._internal_time());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_heading()->::proto::nav_info::Heading::MergeFrom(from._internal_heading());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_position()->::proto::nav_info::Position::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_grid_description()->::proto::grid_description::GridDescription::MergeFrom(from._internal_grid_description());
    }
    if (cached_has_bits & 0x00000020u) {
      max_depth_ = from.max_depth_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_range_index_ = from.max_range_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TargetData::CopyFrom(const TargetData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.TargetData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TargetData::IsInitialized() const {
  return true;
}

void TargetData::InternalSwap(TargetData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  bottom_.InternalSwap(&other->bottom_);
  groups_.InternalSwap(&other->groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_, lhs_arena,
      &other->serial_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TargetData, max_range_index_)
      + sizeof(TargetData::max_range_index_)
      - PROTOBUF_FIELD_OFFSET(TargetData, time_)>(
          reinterpret_cast<char*>(&time_),
          reinterpret_cast<char*>(&other->time_));
}

std::string TargetData::GetTypeName() const {
  return "proto.nav_api.TargetData";
}


// ===================================================================

class Bin::_Internal {
 public:
  using HasBits = decltype(std::declval<Bin>()._has_bits_);
  static void set_has_hor_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ver_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_range_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cross_range(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_down_range(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_strength(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_confidence(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Bin::Bin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.Bin)
}
Bin::Bin(const Bin& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&hor_index_, &from.hor_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&confidence_) -
    reinterpret_cast<char*>(&hor_index_)) + sizeof(confidence_));
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.Bin)
}

inline void Bin::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hor_index_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&confidence_) -
    reinterpret_cast<char*>(&hor_index_)) + sizeof(confidence_));
}

Bin::~Bin() {
  // @@protoc_insertion_point(destructor:proto.nav_api.Bin)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Bin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Bin::ArenaDtor(void* object) {
  Bin* _this = reinterpret_cast< Bin* >(object);
  (void)_this;
}
void Bin::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Bin::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Bin::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.Bin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&hor_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&confidence_) -
        reinterpret_cast<char*>(&hor_index_)) + sizeof(confidence_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Bin::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 hor_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hor_index(&has_bits);
          hor_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ver_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ver_index(&has_bits);
          ver_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 range_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_range_index(&has_bits);
          range_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float cross_range = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_cross_range(&has_bits);
          cross_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float down_range = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_down_range(&has_bits);
          down_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float depth = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float strength = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_strength(&has_bits);
          strength_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float confidence = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_confidence(&has_bits);
          confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Bin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.Bin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 hor_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_hor_index(), target);
  }

  // optional int32 ver_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_ver_index(), target);
  }

  // optional int32 range_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_range_index(), target);
  }

  // optional float cross_range = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_cross_range(), target);
  }

  // optional float down_range = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_down_range(), target);
  }

  // optional float depth = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_depth(), target);
  }

  // optional float strength = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_strength(), target);
  }

  // optional float confidence = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_confidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.Bin)
  return target;
}

size_t Bin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.Bin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 hor_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_hor_index());
    }

    // optional int32 ver_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_ver_index());
    }

    // optional int32 range_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_range_index());
    }

    // optional float cross_range = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float down_range = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float depth = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float strength = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float confidence = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Bin::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Bin*>(
      &from));
}

void Bin::MergeFrom(const Bin& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.Bin)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      hor_index_ = from.hor_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      ver_index_ = from.ver_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      range_index_ = from.range_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      cross_range_ = from.cross_range_;
    }
    if (cached_has_bits & 0x00000010u) {
      down_range_ = from.down_range_;
    }
    if (cached_has_bits & 0x00000020u) {
      depth_ = from.depth_;
    }
    if (cached_has_bits & 0x00000040u) {
      strength_ = from.strength_;
    }
    if (cached_has_bits & 0x00000080u) {
      confidence_ = from.confidence_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Bin::CopyFrom(const Bin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.Bin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bin::IsInitialized() const {
  return true;
}

void Bin::InternalSwap(Bin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Bin, confidence_)
      + sizeof(Bin::confidence_)
      - PROTOBUF_FIELD_OFFSET(Bin, hor_index_)>(
          reinterpret_cast<char*>(&hor_index_),
          reinterpret_cast<char*>(&other->hor_index_));
}

std::string Bin::GetTypeName() const {
  return "proto.nav_api.Bin";
}


// ===================================================================

class Group::_Internal {
 public:
};

Group::Group(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  bins_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.Group)
}
Group::Group(const Group& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      bins_(from.bins_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.Group)
}

inline void Group::SharedCtor() {
}

Group::~Group() {
  // @@protoc_insertion_point(destructor:proto.nav_api.Group)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Group::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Group::ArenaDtor(void* object) {
  Group* _this = reinterpret_cast< Group* >(object);
  (void)_this;
}
void Group::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Group::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Group::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.Group)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bins_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Group::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.nav_api.Bin bins = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bins(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Group::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.Group)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.nav_api.Bin bins = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_bins_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_bins(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.Group)
  return target;
}

size_t Group::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.Group)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.nav_api.Bin bins = 1;
  total_size += 1UL * this->_internal_bins_size();
  for (const auto& msg : this->bins_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Group::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Group*>(
      &from));
}

void Group::MergeFrom(const Group& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.Group)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  bins_.MergeFrom(from.bins_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Group::CopyFrom(const Group& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.Group)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Group::IsInitialized() const {
  return true;
}

void Group::InternalSwap(Group* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  bins_.InternalSwap(&other->bins_);
}

std::string Group::GetTypeName() const {
  return "proto.nav_api.Group";
}


// ===================================================================

class ProcessorSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<ProcessorSettings>()._has_bits_);
  static const ::proto::time::Time& time(const ProcessorSettings* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min_inwater_squelch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_inwater_squelch(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_inwater_squelch(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_squelchless_inwater_detector(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_detect_bottom(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_system_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_fov(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::proto::time::Time&
ProcessorSettings::_Internal::time(const ProcessorSettings* msg) {
  return *msg->time_;
}
void ProcessorSettings::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ProcessorSettings::ProcessorSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.ProcessorSettings)
}
ProcessorSettings::ProcessorSettings(const ProcessorSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_time()) {
    time_ = new ::proto::time::Time(*from.time_);
  } else {
    time_ = nullptr;
  }
  ::memcpy(&min_inwater_squelch_, &from.min_inwater_squelch_,
    static_cast<size_t>(reinterpret_cast<char*>(&fov_) -
    reinterpret_cast<char*>(&min_inwater_squelch_)) + sizeof(fov_));
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.ProcessorSettings)
}

inline void ProcessorSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&system_type_) -
    reinterpret_cast<char*>(&time_)) + sizeof(system_type_));
fov_ = 2;
}

ProcessorSettings::~ProcessorSettings() {
  // @@protoc_insertion_point(destructor:proto.nav_api.ProcessorSettings)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ProcessorSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete time_;
}

void ProcessorSettings::ArenaDtor(void* object) {
  ProcessorSettings* _this = reinterpret_cast< ProcessorSettings* >(object);
  (void)_this;
}
void ProcessorSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ProcessorSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ProcessorSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.ProcessorSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&min_inwater_squelch_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&system_type_) -
        reinterpret_cast<char*>(&min_inwater_squelch_)) + sizeof(system_type_));
    fov_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProcessorSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.time.Time time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float min_inwater_squelch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_min_inwater_squelch(&has_bits);
          min_inwater_squelch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_inwater_squelch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_max_inwater_squelch(&has_bits);
          max_inwater_squelch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float inwater_squelch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_inwater_squelch(&has_bits);
          inwater_squelch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool squelchless_inwater_detector = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_squelchless_inwater_detector(&has_bits);
          squelchless_inwater_detector_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool detect_bottom = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_detect_bottom(&has_bits);
          detect_bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .proto.nav_api.ProcessorSettings.SystemType system_type = 7 [default = kFS3DT];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::proto::nav_api::ProcessorSettings_SystemType_IsValid(val))) {
            _internal_set_system_type(static_cast<::proto::nav_api::ProcessorSettings_SystemType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .proto.nav_api.FieldOfView fov = 8 [default = k90d330m];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::proto::nav_api::FieldOfView_IsValid(val))) {
            _internal_set_fov(static_cast<::proto::nav_api::FieldOfView>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessorSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.ProcessorSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.time.Time time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::time(this), target, stream);
  }

  // optional float min_inwater_squelch = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_min_inwater_squelch(), target);
  }

  // optional float max_inwater_squelch = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_max_inwater_squelch(), target);
  }

  // optional float inwater_squelch = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_inwater_squelch(), target);
  }

  // optional bool squelchless_inwater_detector = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_squelchless_inwater_detector(), target);
  }

  // optional bool detect_bottom = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_detect_bottom(), target);
  }

  // optional .proto.nav_api.ProcessorSettings.SystemType system_type = 7 [default = kFS3DT];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_system_type(), target);
  }

  // optional .proto.nav_api.FieldOfView fov = 8 [default = k90d330m];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_fov(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.ProcessorSettings)
  return target;
}

size_t ProcessorSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.ProcessorSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .proto.time.Time time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *time_);
    }

    // optional float min_inwater_squelch = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float max_inwater_squelch = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float inwater_squelch = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool squelchless_inwater_detector = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool detect_bottom = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional .proto.nav_api.ProcessorSettings.SystemType system_type = 7 [default = kFS3DT];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_system_type());
    }

    // optional .proto.nav_api.FieldOfView fov = 8 [default = k90d330m];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_fov());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProcessorSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ProcessorSettings*>(
      &from));
}

void ProcessorSettings::MergeFrom(const ProcessorSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.ProcessorSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_time()->::proto::time::Time::MergeFrom(from._internal_time());
    }
    if (cached_has_bits & 0x00000002u) {
      min_inwater_squelch_ = from.min_inwater_squelch_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_inwater_squelch_ = from.max_inwater_squelch_;
    }
    if (cached_has_bits & 0x00000008u) {
      inwater_squelch_ = from.inwater_squelch_;
    }
    if (cached_has_bits & 0x00000010u) {
      squelchless_inwater_detector_ = from.squelchless_inwater_detector_;
    }
    if (cached_has_bits & 0x00000020u) {
      detect_bottom_ = from.detect_bottom_;
    }
    if (cached_has_bits & 0x00000040u) {
      system_type_ = from.system_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      fov_ = from.fov_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessorSettings::CopyFrom(const ProcessorSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.ProcessorSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessorSettings::IsInitialized() const {
  return true;
}

void ProcessorSettings::InternalSwap(ProcessorSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProcessorSettings, system_type_)
      + sizeof(ProcessorSettings::system_type_)
      - PROTOBUF_FIELD_OFFSET(ProcessorSettings, time_)>(
          reinterpret_cast<char*>(&time_),
          reinterpret_cast<char*>(&other->time_));
  swap(fov_, other->fov_);
}

std::string ProcessorSettings::GetTypeName() const {
  return "proto.nav_api.ProcessorSettings";
}


// ===================================================================

class GetProcessorSettingsRequest::_Internal {
 public:
};

GetProcessorSettingsRequest::GetProcessorSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.GetProcessorSettingsRequest)
}
GetProcessorSettingsRequest::GetProcessorSettingsRequest(const GetProcessorSettingsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.GetProcessorSettingsRequest)
}

inline void GetProcessorSettingsRequest::SharedCtor() {
}

GetProcessorSettingsRequest::~GetProcessorSettingsRequest() {
  // @@protoc_insertion_point(destructor:proto.nav_api.GetProcessorSettingsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GetProcessorSettingsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetProcessorSettingsRequest::ArenaDtor(void* object) {
  GetProcessorSettingsRequest* _this = reinterpret_cast< GetProcessorSettingsRequest* >(object);
  (void)_this;
}
void GetProcessorSettingsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetProcessorSettingsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetProcessorSettingsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.GetProcessorSettingsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* GetProcessorSettingsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetProcessorSettingsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.GetProcessorSettingsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.GetProcessorSettingsRequest)
  return target;
}

size_t GetProcessorSettingsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.GetProcessorSettingsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetProcessorSettingsRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GetProcessorSettingsRequest*>(
      &from));
}

void GetProcessorSettingsRequest::MergeFrom(const GetProcessorSettingsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.GetProcessorSettingsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetProcessorSettingsRequest::CopyFrom(const GetProcessorSettingsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.GetProcessorSettingsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetProcessorSettingsRequest::IsInitialized() const {
  return true;
}

void GetProcessorSettingsRequest::InternalSwap(GetProcessorSettingsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string GetProcessorSettingsRequest::GetTypeName() const {
  return "proto.nav_api.GetProcessorSettingsRequest";
}


// ===================================================================

class GetProcessorSettingsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<GetProcessorSettingsResponse>()._has_bits_);
  static const ::proto::nav_api::RequestResult& result(const GetProcessorSettingsResponse* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::proto::nav_api::ProcessorSettings& settings(const GetProcessorSettingsResponse* msg);
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::proto::nav_api::RequestResult&
GetProcessorSettingsResponse::_Internal::result(const GetProcessorSettingsResponse* msg) {
  return *msg->result_;
}
const ::proto::nav_api::ProcessorSettings&
GetProcessorSettingsResponse::_Internal::settings(const GetProcessorSettingsResponse* msg) {
  return *msg->settings_;
}
GetProcessorSettingsResponse::GetProcessorSettingsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.GetProcessorSettingsResponse)
}
GetProcessorSettingsResponse::GetProcessorSettingsResponse(const GetProcessorSettingsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result()) {
    result_ = new ::proto::nav_api::RequestResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  if (from._internal_has_settings()) {
    settings_ = new ::proto::nav_api::ProcessorSettings(*from.settings_);
  } else {
    settings_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.GetProcessorSettingsResponse)
}

inline void GetProcessorSettingsResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&result_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&settings_) -
    reinterpret_cast<char*>(&result_)) + sizeof(settings_));
}

GetProcessorSettingsResponse::~GetProcessorSettingsResponse() {
  // @@protoc_insertion_point(destructor:proto.nav_api.GetProcessorSettingsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GetProcessorSettingsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_;
  if (this != internal_default_instance()) delete settings_;
}

void GetProcessorSettingsResponse::ArenaDtor(void* object) {
  GetProcessorSettingsResponse* _this = reinterpret_cast< GetProcessorSettingsResponse* >(object);
  (void)_this;
}
void GetProcessorSettingsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetProcessorSettingsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetProcessorSettingsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.GetProcessorSettingsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(result_ != nullptr);
      result_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(settings_ != nullptr);
      settings_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetProcessorSettingsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.RequestResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .proto.nav_api.ProcessorSettings settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetProcessorSettingsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.GetProcessorSettingsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.RequestResult result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::result(this), target, stream);
  }

  // optional .proto.nav_api.ProcessorSettings settings = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::settings(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.GetProcessorSettingsResponse)
  return target;
}

size_t GetProcessorSettingsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.GetProcessorSettingsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .proto.nav_api.RequestResult result = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_);
    }

    // optional .proto.nav_api.ProcessorSettings settings = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *settings_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetProcessorSettingsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GetProcessorSettingsResponse*>(
      &from));
}

void GetProcessorSettingsResponse::MergeFrom(const GetProcessorSettingsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.GetProcessorSettingsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_result()->::proto::nav_api::RequestResult::MergeFrom(from._internal_result());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_settings()->::proto::nav_api::ProcessorSettings::MergeFrom(from._internal_settings());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetProcessorSettingsResponse::CopyFrom(const GetProcessorSettingsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.GetProcessorSettingsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetProcessorSettingsResponse::IsInitialized() const {
  return true;
}

void GetProcessorSettingsResponse::InternalSwap(GetProcessorSettingsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetProcessorSettingsResponse, settings_)
      + sizeof(GetProcessorSettingsResponse::settings_)
      - PROTOBUF_FIELD_OFFSET(GetProcessorSettingsResponse, result_)>(
          reinterpret_cast<char*>(&result_),
          reinterpret_cast<char*>(&other->result_));
}

std::string GetProcessorSettingsResponse::GetTypeName() const {
  return "proto.nav_api.GetProcessorSettingsResponse";
}


// ===================================================================

class SetFieldOfViewRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetFieldOfViewRequest>()._has_bits_);
  static void set_has_fov(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SetFieldOfViewRequest::SetFieldOfViewRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetFieldOfViewRequest)
}
SetFieldOfViewRequest::SetFieldOfViewRequest(const SetFieldOfViewRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  fov_ = from.fov_;
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetFieldOfViewRequest)
}

inline void SetFieldOfViewRequest::SharedCtor() {
fov_ = 0;
}

SetFieldOfViewRequest::~SetFieldOfViewRequest() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetFieldOfViewRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetFieldOfViewRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetFieldOfViewRequest::ArenaDtor(void* object) {
  SetFieldOfViewRequest* _this = reinterpret_cast< SetFieldOfViewRequest* >(object);
  (void)_this;
}
void SetFieldOfViewRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetFieldOfViewRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetFieldOfViewRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetFieldOfViewRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fov_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetFieldOfViewRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.FieldOfView fov = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::proto::nav_api::FieldOfView_IsValid(val))) {
            _internal_set_fov(static_cast<::proto::nav_api::FieldOfView>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetFieldOfViewRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetFieldOfViewRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.FieldOfView fov = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_fov(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetFieldOfViewRequest)
  return target;
}

size_t SetFieldOfViewRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetFieldOfViewRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .proto.nav_api.FieldOfView fov = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_fov());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetFieldOfViewRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetFieldOfViewRequest*>(
      &from));
}

void SetFieldOfViewRequest::MergeFrom(const SetFieldOfViewRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetFieldOfViewRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_fov()) {
    _internal_set_fov(from._internal_fov());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetFieldOfViewRequest::CopyFrom(const SetFieldOfViewRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetFieldOfViewRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetFieldOfViewRequest::IsInitialized() const {
  return true;
}

void SetFieldOfViewRequest::InternalSwap(SetFieldOfViewRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(fov_, other->fov_);
}

std::string SetFieldOfViewRequest::GetTypeName() const {
  return "proto.nav_api.SetFieldOfViewRequest";
}


// ===================================================================

class SetFieldOfViewResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SetFieldOfViewResponse>()._has_bits_);
  static const ::proto::nav_api::RequestResult& result(const SetFieldOfViewResponse* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::proto::nav_api::RequestResult&
SetFieldOfViewResponse::_Internal::result(const SetFieldOfViewResponse* msg) {
  return *msg->result_;
}
SetFieldOfViewResponse::SetFieldOfViewResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetFieldOfViewResponse)
}
SetFieldOfViewResponse::SetFieldOfViewResponse(const SetFieldOfViewResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result()) {
    result_ = new ::proto::nav_api::RequestResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetFieldOfViewResponse)
}

inline void SetFieldOfViewResponse::SharedCtor() {
result_ = nullptr;
}

SetFieldOfViewResponse::~SetFieldOfViewResponse() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetFieldOfViewResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetFieldOfViewResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_;
}

void SetFieldOfViewResponse::ArenaDtor(void* object) {
  SetFieldOfViewResponse* _this = reinterpret_cast< SetFieldOfViewResponse* >(object);
  (void)_this;
}
void SetFieldOfViewResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetFieldOfViewResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetFieldOfViewResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetFieldOfViewResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(result_ != nullptr);
    result_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetFieldOfViewResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.RequestResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetFieldOfViewResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetFieldOfViewResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.RequestResult result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::result(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetFieldOfViewResponse)
  return target;
}

size_t SetFieldOfViewResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetFieldOfViewResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .proto.nav_api.RequestResult result = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *result_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetFieldOfViewResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetFieldOfViewResponse*>(
      &from));
}

void SetFieldOfViewResponse::MergeFrom(const SetFieldOfViewResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetFieldOfViewResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_mutable_result()->::proto::nav_api::RequestResult::MergeFrom(from._internal_result());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetFieldOfViewResponse::CopyFrom(const SetFieldOfViewResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetFieldOfViewResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetFieldOfViewResponse::IsInitialized() const {
  return true;
}

void SetFieldOfViewResponse::InternalSwap(SetFieldOfViewResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

std::string SetFieldOfViewResponse::GetTypeName() const {
  return "proto.nav_api.SetFieldOfViewResponse";
}


// ===================================================================

class SetBottomDetectionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetBottomDetectionRequest>()._has_bits_);
  static void set_has_enable_bottom_detection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SetBottomDetectionRequest::SetBottomDetectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetBottomDetectionRequest)
}
SetBottomDetectionRequest::SetBottomDetectionRequest(const SetBottomDetectionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  enable_bottom_detection_ = from.enable_bottom_detection_;
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetBottomDetectionRequest)
}

inline void SetBottomDetectionRequest::SharedCtor() {
enable_bottom_detection_ = false;
}

SetBottomDetectionRequest::~SetBottomDetectionRequest() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetBottomDetectionRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetBottomDetectionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetBottomDetectionRequest::ArenaDtor(void* object) {
  SetBottomDetectionRequest* _this = reinterpret_cast< SetBottomDetectionRequest* >(object);
  (void)_this;
}
void SetBottomDetectionRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetBottomDetectionRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetBottomDetectionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetBottomDetectionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enable_bottom_detection_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetBottomDetectionRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable_bottom_detection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_bottom_detection(&has_bits);
          enable_bottom_detection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetBottomDetectionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetBottomDetectionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool enable_bottom_detection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_bottom_detection(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetBottomDetectionRequest)
  return target;
}

size_t SetBottomDetectionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetBottomDetectionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enable_bottom_detection = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetBottomDetectionRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetBottomDetectionRequest*>(
      &from));
}

void SetBottomDetectionRequest::MergeFrom(const SetBottomDetectionRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetBottomDetectionRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enable_bottom_detection()) {
    _internal_set_enable_bottom_detection(from._internal_enable_bottom_detection());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetBottomDetectionRequest::CopyFrom(const SetBottomDetectionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetBottomDetectionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetBottomDetectionRequest::IsInitialized() const {
  return true;
}

void SetBottomDetectionRequest::InternalSwap(SetBottomDetectionRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(enable_bottom_detection_, other->enable_bottom_detection_);
}

std::string SetBottomDetectionRequest::GetTypeName() const {
  return "proto.nav_api.SetBottomDetectionRequest";
}


// ===================================================================

class SetBottomDetectionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SetBottomDetectionResponse>()._has_bits_);
  static const ::proto::nav_api::RequestResult& result(const SetBottomDetectionResponse* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::proto::nav_api::RequestResult&
SetBottomDetectionResponse::_Internal::result(const SetBottomDetectionResponse* msg) {
  return *msg->result_;
}
SetBottomDetectionResponse::SetBottomDetectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetBottomDetectionResponse)
}
SetBottomDetectionResponse::SetBottomDetectionResponse(const SetBottomDetectionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result()) {
    result_ = new ::proto::nav_api::RequestResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetBottomDetectionResponse)
}

inline void SetBottomDetectionResponse::SharedCtor() {
result_ = nullptr;
}

SetBottomDetectionResponse::~SetBottomDetectionResponse() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetBottomDetectionResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetBottomDetectionResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_;
}

void SetBottomDetectionResponse::ArenaDtor(void* object) {
  SetBottomDetectionResponse* _this = reinterpret_cast< SetBottomDetectionResponse* >(object);
  (void)_this;
}
void SetBottomDetectionResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetBottomDetectionResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetBottomDetectionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetBottomDetectionResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(result_ != nullptr);
    result_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetBottomDetectionResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.RequestResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetBottomDetectionResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetBottomDetectionResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.RequestResult result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::result(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetBottomDetectionResponse)
  return target;
}

size_t SetBottomDetectionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetBottomDetectionResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .proto.nav_api.RequestResult result = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *result_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetBottomDetectionResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetBottomDetectionResponse*>(
      &from));
}

void SetBottomDetectionResponse::MergeFrom(const SetBottomDetectionResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetBottomDetectionResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_mutable_result()->::proto::nav_api::RequestResult::MergeFrom(from._internal_result());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetBottomDetectionResponse::CopyFrom(const SetBottomDetectionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetBottomDetectionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetBottomDetectionResponse::IsInitialized() const {
  return true;
}

void SetBottomDetectionResponse::InternalSwap(SetBottomDetectionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

std::string SetBottomDetectionResponse::GetTypeName() const {
  return "proto.nav_api.SetBottomDetectionResponse";
}


// ===================================================================

class SetInWaterSquelchRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetInWaterSquelchRequest>()._has_bits_);
  static void set_has_new_squelch_val(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SetInWaterSquelchRequest::SetInWaterSquelchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetInWaterSquelchRequest)
}
SetInWaterSquelchRequest::SetInWaterSquelchRequest(const SetInWaterSquelchRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  new_squelch_val_ = from.new_squelch_val_;
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetInWaterSquelchRequest)
}

inline void SetInWaterSquelchRequest::SharedCtor() {
new_squelch_val_ = 0;
}

SetInWaterSquelchRequest::~SetInWaterSquelchRequest() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetInWaterSquelchRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetInWaterSquelchRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetInWaterSquelchRequest::ArenaDtor(void* object) {
  SetInWaterSquelchRequest* _this = reinterpret_cast< SetInWaterSquelchRequest* >(object);
  (void)_this;
}
void SetInWaterSquelchRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetInWaterSquelchRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetInWaterSquelchRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetInWaterSquelchRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  new_squelch_val_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetInWaterSquelchRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float new_squelch_val = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_new_squelch_val(&has_bits);
          new_squelch_val_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetInWaterSquelchRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetInWaterSquelchRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float new_squelch_val = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_new_squelch_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetInWaterSquelchRequest)
  return target;
}

size_t SetInWaterSquelchRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetInWaterSquelchRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float new_squelch_val = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetInWaterSquelchRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetInWaterSquelchRequest*>(
      &from));
}

void SetInWaterSquelchRequest::MergeFrom(const SetInWaterSquelchRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetInWaterSquelchRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_new_squelch_val()) {
    _internal_set_new_squelch_val(from._internal_new_squelch_val());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetInWaterSquelchRequest::CopyFrom(const SetInWaterSquelchRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetInWaterSquelchRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetInWaterSquelchRequest::IsInitialized() const {
  return true;
}

void SetInWaterSquelchRequest::InternalSwap(SetInWaterSquelchRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(new_squelch_val_, other->new_squelch_val_);
}

std::string SetInWaterSquelchRequest::GetTypeName() const {
  return "proto.nav_api.SetInWaterSquelchRequest";
}


// ===================================================================

class SetInWaterSquelchResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SetInWaterSquelchResponse>()._has_bits_);
  static const ::proto::nav_api::RequestResult& result(const SetInWaterSquelchResponse* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::proto::nav_api::RequestResult&
SetInWaterSquelchResponse::_Internal::result(const SetInWaterSquelchResponse* msg) {
  return *msg->result_;
}
SetInWaterSquelchResponse::SetInWaterSquelchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetInWaterSquelchResponse)
}
SetInWaterSquelchResponse::SetInWaterSquelchResponse(const SetInWaterSquelchResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result()) {
    result_ = new ::proto::nav_api::RequestResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetInWaterSquelchResponse)
}

inline void SetInWaterSquelchResponse::SharedCtor() {
result_ = nullptr;
}

SetInWaterSquelchResponse::~SetInWaterSquelchResponse() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetInWaterSquelchResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetInWaterSquelchResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_;
}

void SetInWaterSquelchResponse::ArenaDtor(void* object) {
  SetInWaterSquelchResponse* _this = reinterpret_cast< SetInWaterSquelchResponse* >(object);
  (void)_this;
}
void SetInWaterSquelchResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetInWaterSquelchResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetInWaterSquelchResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetInWaterSquelchResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(result_ != nullptr);
    result_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetInWaterSquelchResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.RequestResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetInWaterSquelchResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetInWaterSquelchResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.RequestResult result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::result(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetInWaterSquelchResponse)
  return target;
}

size_t SetInWaterSquelchResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetInWaterSquelchResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .proto.nav_api.RequestResult result = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *result_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetInWaterSquelchResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetInWaterSquelchResponse*>(
      &from));
}

void SetInWaterSquelchResponse::MergeFrom(const SetInWaterSquelchResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetInWaterSquelchResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_mutable_result()->::proto::nav_api::RequestResult::MergeFrom(from._internal_result());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetInWaterSquelchResponse::CopyFrom(const SetInWaterSquelchResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetInWaterSquelchResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetInWaterSquelchResponse::IsInitialized() const {
  return true;
}

void SetInWaterSquelchResponse::InternalSwap(SetInWaterSquelchResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

std::string SetInWaterSquelchResponse::GetTypeName() const {
  return "proto.nav_api.SetInWaterSquelchResponse";
}


// ===================================================================

class SetSquelchlessInWaterDetectorRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetSquelchlessInWaterDetectorRequest>()._has_bits_);
  static void set_has_enable_squelchless_detection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SetSquelchlessInWaterDetectorRequest::SetSquelchlessInWaterDetectorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
}
SetSquelchlessInWaterDetectorRequest::SetSquelchlessInWaterDetectorRequest(const SetSquelchlessInWaterDetectorRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  enable_squelchless_detection_ = from.enable_squelchless_detection_;
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
}

inline void SetSquelchlessInWaterDetectorRequest::SharedCtor() {
enable_squelchless_detection_ = false;
}

SetSquelchlessInWaterDetectorRequest::~SetSquelchlessInWaterDetectorRequest() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetSquelchlessInWaterDetectorRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetSquelchlessInWaterDetectorRequest::ArenaDtor(void* object) {
  SetSquelchlessInWaterDetectorRequest* _this = reinterpret_cast< SetSquelchlessInWaterDetectorRequest* >(object);
  (void)_this;
}
void SetSquelchlessInWaterDetectorRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetSquelchlessInWaterDetectorRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetSquelchlessInWaterDetectorRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enable_squelchless_detection_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetSquelchlessInWaterDetectorRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable_squelchless_detection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_squelchless_detection(&has_bits);
          enable_squelchless_detection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetSquelchlessInWaterDetectorRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool enable_squelchless_detection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_squelchless_detection(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
  return target;
}

size_t SetSquelchlessInWaterDetectorRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enable_squelchless_detection = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetSquelchlessInWaterDetectorRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetSquelchlessInWaterDetectorRequest*>(
      &from));
}

void SetSquelchlessInWaterDetectorRequest::MergeFrom(const SetSquelchlessInWaterDetectorRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enable_squelchless_detection()) {
    _internal_set_enable_squelchless_detection(from._internal_enable_squelchless_detection());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetSquelchlessInWaterDetectorRequest::CopyFrom(const SetSquelchlessInWaterDetectorRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetSquelchlessInWaterDetectorRequest::IsInitialized() const {
  return true;
}

void SetSquelchlessInWaterDetectorRequest::InternalSwap(SetSquelchlessInWaterDetectorRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(enable_squelchless_detection_, other->enable_squelchless_detection_);
}

std::string SetSquelchlessInWaterDetectorRequest::GetTypeName() const {
  return "proto.nav_api.SetSquelchlessInWaterDetectorRequest";
}


// ===================================================================

class SetSquelchlessInWaterDetectorResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SetSquelchlessInWaterDetectorResponse>()._has_bits_);
  static const ::proto::nav_api::RequestResult& result(const SetSquelchlessInWaterDetectorResponse* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::proto::nav_api::RequestResult&
SetSquelchlessInWaterDetectorResponse::_Internal::result(const SetSquelchlessInWaterDetectorResponse* msg) {
  return *msg->result_;
}
SetSquelchlessInWaterDetectorResponse::SetSquelchlessInWaterDetectorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
}
SetSquelchlessInWaterDetectorResponse::SetSquelchlessInWaterDetectorResponse(const SetSquelchlessInWaterDetectorResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result()) {
    result_ = new ::proto::nav_api::RequestResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
}

inline void SetSquelchlessInWaterDetectorResponse::SharedCtor() {
result_ = nullptr;
}

SetSquelchlessInWaterDetectorResponse::~SetSquelchlessInWaterDetectorResponse() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetSquelchlessInWaterDetectorResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_;
}

void SetSquelchlessInWaterDetectorResponse::ArenaDtor(void* object) {
  SetSquelchlessInWaterDetectorResponse* _this = reinterpret_cast< SetSquelchlessInWaterDetectorResponse* >(object);
  (void)_this;
}
void SetSquelchlessInWaterDetectorResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetSquelchlessInWaterDetectorResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetSquelchlessInWaterDetectorResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(result_ != nullptr);
    result_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetSquelchlessInWaterDetectorResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.RequestResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetSquelchlessInWaterDetectorResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.RequestResult result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::result(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
  return target;
}

size_t SetSquelchlessInWaterDetectorResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .proto.nav_api.RequestResult result = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *result_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetSquelchlessInWaterDetectorResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetSquelchlessInWaterDetectorResponse*>(
      &from));
}

void SetSquelchlessInWaterDetectorResponse::MergeFrom(const SetSquelchlessInWaterDetectorResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_mutable_result()->::proto::nav_api::RequestResult::MergeFrom(from._internal_result());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetSquelchlessInWaterDetectorResponse::CopyFrom(const SetSquelchlessInWaterDetectorResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetSquelchlessInWaterDetectorResponse::IsInitialized() const {
  return true;
}

void SetSquelchlessInWaterDetectorResponse::InternalSwap(SetSquelchlessInWaterDetectorResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

std::string SetSquelchlessInWaterDetectorResponse::GetTypeName() const {
  return "proto.nav_api.SetSquelchlessInWaterDetectorResponse";
}


// ===================================================================

class VesselInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<VesselInfo>()._has_bits_);
  static void set_has_draft(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_keel_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

VesselInfo::VesselInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.VesselInfo)
}
VesselInfo::VesselInfo(const VesselInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&draft_, &from.draft_,
    static_cast<size_t>(reinterpret_cast<char*>(&keel_offset_) -
    reinterpret_cast<char*>(&draft_)) + sizeof(keel_offset_));
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.VesselInfo)
}

inline void VesselInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&draft_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&keel_offset_) -
    reinterpret_cast<char*>(&draft_)) + sizeof(keel_offset_));
}

VesselInfo::~VesselInfo() {
  // @@protoc_insertion_point(destructor:proto.nav_api.VesselInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void VesselInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VesselInfo::ArenaDtor(void* object) {
  VesselInfo* _this = reinterpret_cast< VesselInfo* >(object);
  (void)_this;
}
void VesselInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VesselInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VesselInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.VesselInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&draft_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&keel_offset_) -
        reinterpret_cast<char*>(&draft_)) + sizeof(keel_offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VesselInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float draft = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_draft(&has_bits);
          draft_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float keel_offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_keel_offset(&has_bits);
          keel_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VesselInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.VesselInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float draft = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_draft(), target);
  }

  // optional float keel_offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_keel_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.VesselInfo)
  return target;
}

size_t VesselInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.VesselInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float draft = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float keel_offset = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VesselInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VesselInfo*>(
      &from));
}

void VesselInfo::MergeFrom(const VesselInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.VesselInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      draft_ = from.draft_;
    }
    if (cached_has_bits & 0x00000002u) {
      keel_offset_ = from.keel_offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VesselInfo::CopyFrom(const VesselInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.VesselInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VesselInfo::IsInitialized() const {
  return true;
}

void VesselInfo::InternalSwap(VesselInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VesselInfo, keel_offset_)
      + sizeof(VesselInfo::keel_offset_)
      - PROTOBUF_FIELD_OFFSET(VesselInfo, draft_)>(
          reinterpret_cast<char*>(&draft_),
          reinterpret_cast<char*>(&other->draft_));
}

std::string VesselInfo::GetTypeName() const {
  return "proto.nav_api.VesselInfo";
}


// ===================================================================

class GetVesselInfoRequest::_Internal {
 public:
};

GetVesselInfoRequest::GetVesselInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.GetVesselInfoRequest)
}
GetVesselInfoRequest::GetVesselInfoRequest(const GetVesselInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.GetVesselInfoRequest)
}

inline void GetVesselInfoRequest::SharedCtor() {
}

GetVesselInfoRequest::~GetVesselInfoRequest() {
  // @@protoc_insertion_point(destructor:proto.nav_api.GetVesselInfoRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GetVesselInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetVesselInfoRequest::ArenaDtor(void* object) {
  GetVesselInfoRequest* _this = reinterpret_cast< GetVesselInfoRequest* >(object);
  (void)_this;
}
void GetVesselInfoRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetVesselInfoRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetVesselInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.GetVesselInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* GetVesselInfoRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetVesselInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.GetVesselInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.GetVesselInfoRequest)
  return target;
}

size_t GetVesselInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.GetVesselInfoRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetVesselInfoRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GetVesselInfoRequest*>(
      &from));
}

void GetVesselInfoRequest::MergeFrom(const GetVesselInfoRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.GetVesselInfoRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetVesselInfoRequest::CopyFrom(const GetVesselInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.GetVesselInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetVesselInfoRequest::IsInitialized() const {
  return true;
}

void GetVesselInfoRequest::InternalSwap(GetVesselInfoRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string GetVesselInfoRequest::GetTypeName() const {
  return "proto.nav_api.GetVesselInfoRequest";
}


// ===================================================================

class GetVesselInfoResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<GetVesselInfoResponse>()._has_bits_);
  static const ::proto::nav_api::RequestResult& result(const GetVesselInfoResponse* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::proto::nav_api::VesselInfo& info(const GetVesselInfoResponse* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::proto::nav_api::RequestResult&
GetVesselInfoResponse::_Internal::result(const GetVesselInfoResponse* msg) {
  return *msg->result_;
}
const ::proto::nav_api::VesselInfo&
GetVesselInfoResponse::_Internal::info(const GetVesselInfoResponse* msg) {
  return *msg->info_;
}
GetVesselInfoResponse::GetVesselInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.GetVesselInfoResponse)
}
GetVesselInfoResponse::GetVesselInfoResponse(const GetVesselInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result()) {
    result_ = new ::proto::nav_api::RequestResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  if (from._internal_has_info()) {
    info_ = new ::proto::nav_api::VesselInfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.GetVesselInfoResponse)
}

inline void GetVesselInfoResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&result_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&info_) -
    reinterpret_cast<char*>(&result_)) + sizeof(info_));
}

GetVesselInfoResponse::~GetVesselInfoResponse() {
  // @@protoc_insertion_point(destructor:proto.nav_api.GetVesselInfoResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GetVesselInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_;
  if (this != internal_default_instance()) delete info_;
}

void GetVesselInfoResponse::ArenaDtor(void* object) {
  GetVesselInfoResponse* _this = reinterpret_cast< GetVesselInfoResponse* >(object);
  (void)_this;
}
void GetVesselInfoResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetVesselInfoResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetVesselInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.GetVesselInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(result_ != nullptr);
      result_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(info_ != nullptr);
      info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetVesselInfoResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.RequestResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .proto.nav_api.VesselInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetVesselInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.GetVesselInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.RequestResult result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::result(this), target, stream);
  }

  // optional .proto.nav_api.VesselInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.GetVesselInfoResponse)
  return target;
}

size_t GetVesselInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.GetVesselInfoResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .proto.nav_api.RequestResult result = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_);
    }

    // optional .proto.nav_api.VesselInfo info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetVesselInfoResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GetVesselInfoResponse*>(
      &from));
}

void GetVesselInfoResponse::MergeFrom(const GetVesselInfoResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.GetVesselInfoResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_result()->::proto::nav_api::RequestResult::MergeFrom(from._internal_result());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_info()->::proto::nav_api::VesselInfo::MergeFrom(from._internal_info());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetVesselInfoResponse::CopyFrom(const GetVesselInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.GetVesselInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetVesselInfoResponse::IsInitialized() const {
  return true;
}

void GetVesselInfoResponse::InternalSwap(GetVesselInfoResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetVesselInfoResponse, info_)
      + sizeof(GetVesselInfoResponse::info_)
      - PROTOBUF_FIELD_OFFSET(GetVesselInfoResponse, result_)>(
          reinterpret_cast<char*>(&result_),
          reinterpret_cast<char*>(&other->result_));
}

std::string GetVesselInfoResponse::GetTypeName() const {
  return "proto.nav_api.GetVesselInfoResponse";
}


// ===================================================================

class SetDraftRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetDraftRequest>()._has_bits_);
  static void set_has_new_draft(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SetDraftRequest::SetDraftRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetDraftRequest)
}
SetDraftRequest::SetDraftRequest(const SetDraftRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  new_draft_ = from.new_draft_;
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetDraftRequest)
}

inline void SetDraftRequest::SharedCtor() {
new_draft_ = 0;
}

SetDraftRequest::~SetDraftRequest() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetDraftRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetDraftRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetDraftRequest::ArenaDtor(void* object) {
  SetDraftRequest* _this = reinterpret_cast< SetDraftRequest* >(object);
  (void)_this;
}
void SetDraftRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetDraftRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetDraftRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetDraftRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  new_draft_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetDraftRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float new_draft = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_new_draft(&has_bits);
          new_draft_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetDraftRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetDraftRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float new_draft = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_new_draft(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetDraftRequest)
  return target;
}

size_t SetDraftRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetDraftRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float new_draft = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetDraftRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetDraftRequest*>(
      &from));
}

void SetDraftRequest::MergeFrom(const SetDraftRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetDraftRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_new_draft()) {
    _internal_set_new_draft(from._internal_new_draft());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetDraftRequest::CopyFrom(const SetDraftRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetDraftRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetDraftRequest::IsInitialized() const {
  return true;
}

void SetDraftRequest::InternalSwap(SetDraftRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(new_draft_, other->new_draft_);
}

std::string SetDraftRequest::GetTypeName() const {
  return "proto.nav_api.SetDraftRequest";
}


// ===================================================================

class SetDraftResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SetDraftResponse>()._has_bits_);
  static const ::proto::nav_api::RequestResult& result(const SetDraftResponse* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::proto::nav_api::RequestResult&
SetDraftResponse::_Internal::result(const SetDraftResponse* msg) {
  return *msg->result_;
}
SetDraftResponse::SetDraftResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetDraftResponse)
}
SetDraftResponse::SetDraftResponse(const SetDraftResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result()) {
    result_ = new ::proto::nav_api::RequestResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetDraftResponse)
}

inline void SetDraftResponse::SharedCtor() {
result_ = nullptr;
}

SetDraftResponse::~SetDraftResponse() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetDraftResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetDraftResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_;
}

void SetDraftResponse::ArenaDtor(void* object) {
  SetDraftResponse* _this = reinterpret_cast< SetDraftResponse* >(object);
  (void)_this;
}
void SetDraftResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetDraftResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetDraftResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetDraftResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(result_ != nullptr);
    result_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetDraftResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.RequestResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetDraftResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetDraftResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.RequestResult result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::result(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetDraftResponse)
  return target;
}

size_t SetDraftResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetDraftResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .proto.nav_api.RequestResult result = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *result_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetDraftResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetDraftResponse*>(
      &from));
}

void SetDraftResponse::MergeFrom(const SetDraftResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetDraftResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_mutable_result()->::proto::nav_api::RequestResult::MergeFrom(from._internal_result());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetDraftResponse::CopyFrom(const SetDraftResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetDraftResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetDraftResponse::IsInitialized() const {
  return true;
}

void SetDraftResponse::InternalSwap(SetDraftResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

std::string SetDraftResponse::GetTypeName() const {
  return "proto.nav_api.SetDraftResponse";
}


// ===================================================================

class SetKeelOffsetRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetKeelOffsetRequest>()._has_bits_);
  static void set_has_new_keel_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SetKeelOffsetRequest::SetKeelOffsetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetKeelOffsetRequest)
}
SetKeelOffsetRequest::SetKeelOffsetRequest(const SetKeelOffsetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  new_keel_offset_ = from.new_keel_offset_;
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetKeelOffsetRequest)
}

inline void SetKeelOffsetRequest::SharedCtor() {
new_keel_offset_ = 0;
}

SetKeelOffsetRequest::~SetKeelOffsetRequest() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetKeelOffsetRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetKeelOffsetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetKeelOffsetRequest::ArenaDtor(void* object) {
  SetKeelOffsetRequest* _this = reinterpret_cast< SetKeelOffsetRequest* >(object);
  (void)_this;
}
void SetKeelOffsetRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetKeelOffsetRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetKeelOffsetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetKeelOffsetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  new_keel_offset_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetKeelOffsetRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float new_keel_offset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_new_keel_offset(&has_bits);
          new_keel_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetKeelOffsetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetKeelOffsetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float new_keel_offset = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_new_keel_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetKeelOffsetRequest)
  return target;
}

size_t SetKeelOffsetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetKeelOffsetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float new_keel_offset = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetKeelOffsetRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetKeelOffsetRequest*>(
      &from));
}

void SetKeelOffsetRequest::MergeFrom(const SetKeelOffsetRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetKeelOffsetRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_new_keel_offset()) {
    _internal_set_new_keel_offset(from._internal_new_keel_offset());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetKeelOffsetRequest::CopyFrom(const SetKeelOffsetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetKeelOffsetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetKeelOffsetRequest::IsInitialized() const {
  return true;
}

void SetKeelOffsetRequest::InternalSwap(SetKeelOffsetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(new_keel_offset_, other->new_keel_offset_);
}

std::string SetKeelOffsetRequest::GetTypeName() const {
  return "proto.nav_api.SetKeelOffsetRequest";
}


// ===================================================================

class SetKeelOffsetResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SetKeelOffsetResponse>()._has_bits_);
  static const ::proto::nav_api::RequestResult& result(const SetKeelOffsetResponse* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::proto::nav_api::RequestResult&
SetKeelOffsetResponse::_Internal::result(const SetKeelOffsetResponse* msg) {
  return *msg->result_;
}
SetKeelOffsetResponse::SetKeelOffsetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto.nav_api.SetKeelOffsetResponse)
}
SetKeelOffsetResponse::SetKeelOffsetResponse(const SetKeelOffsetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result()) {
    result_ = new ::proto::nav_api::RequestResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.nav_api.SetKeelOffsetResponse)
}

inline void SetKeelOffsetResponse::SharedCtor() {
result_ = nullptr;
}

SetKeelOffsetResponse::~SetKeelOffsetResponse() {
  // @@protoc_insertion_point(destructor:proto.nav_api.SetKeelOffsetResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SetKeelOffsetResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_;
}

void SetKeelOffsetResponse::ArenaDtor(void* object) {
  SetKeelOffsetResponse* _this = reinterpret_cast< SetKeelOffsetResponse* >(object);
  (void)_this;
}
void SetKeelOffsetResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetKeelOffsetResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetKeelOffsetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.nav_api.SetKeelOffsetResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(result_ != nullptr);
    result_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetKeelOffsetResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .proto.nav_api.RequestResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetKeelOffsetResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.nav_api.SetKeelOffsetResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.nav_api.RequestResult result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::result(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.nav_api.SetKeelOffsetResponse)
  return target;
}

size_t SetKeelOffsetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.nav_api.SetKeelOffsetResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .proto.nav_api.RequestResult result = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *result_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetKeelOffsetResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SetKeelOffsetResponse*>(
      &from));
}

void SetKeelOffsetResponse::MergeFrom(const SetKeelOffsetResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.nav_api.SetKeelOffsetResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_mutable_result()->::proto::nav_api::RequestResult::MergeFrom(from._internal_result());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetKeelOffsetResponse::CopyFrom(const SetKeelOffsetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.nav_api.SetKeelOffsetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetKeelOffsetResponse::IsInitialized() const {
  return true;
}

void SetKeelOffsetResponse::InternalSwap(SetKeelOffsetResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

std::string SetKeelOffsetResponse::GetTypeName() const {
  return "proto.nav_api.SetKeelOffsetResponse";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace nav_api
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::nav_api::RequestResult* Arena::CreateMaybeMessage< ::proto::nav_api::RequestResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::RequestResult >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::HydrophoneData* Arena::CreateMaybeMessage< ::proto::nav_api::HydrophoneData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::HydrophoneData >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::TargetData* Arena::CreateMaybeMessage< ::proto::nav_api::TargetData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::TargetData >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::Bin* Arena::CreateMaybeMessage< ::proto::nav_api::Bin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::Bin >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::Group* Arena::CreateMaybeMessage< ::proto::nav_api::Group >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::Group >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::ProcessorSettings* Arena::CreateMaybeMessage< ::proto::nav_api::ProcessorSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::ProcessorSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::GetProcessorSettingsRequest* Arena::CreateMaybeMessage< ::proto::nav_api::GetProcessorSettingsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::GetProcessorSettingsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::GetProcessorSettingsResponse* Arena::CreateMaybeMessage< ::proto::nav_api::GetProcessorSettingsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::GetProcessorSettingsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetFieldOfViewRequest* Arena::CreateMaybeMessage< ::proto::nav_api::SetFieldOfViewRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetFieldOfViewRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetFieldOfViewResponse* Arena::CreateMaybeMessage< ::proto::nav_api::SetFieldOfViewResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetFieldOfViewResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetBottomDetectionRequest* Arena::CreateMaybeMessage< ::proto::nav_api::SetBottomDetectionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetBottomDetectionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetBottomDetectionResponse* Arena::CreateMaybeMessage< ::proto::nav_api::SetBottomDetectionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetBottomDetectionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetInWaterSquelchRequest* Arena::CreateMaybeMessage< ::proto::nav_api::SetInWaterSquelchRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetInWaterSquelchRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetInWaterSquelchResponse* Arena::CreateMaybeMessage< ::proto::nav_api::SetInWaterSquelchResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetInWaterSquelchResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetSquelchlessInWaterDetectorRequest* Arena::CreateMaybeMessage< ::proto::nav_api::SetSquelchlessInWaterDetectorRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetSquelchlessInWaterDetectorRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetSquelchlessInWaterDetectorResponse* Arena::CreateMaybeMessage< ::proto::nav_api::SetSquelchlessInWaterDetectorResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetSquelchlessInWaterDetectorResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::VesselInfo* Arena::CreateMaybeMessage< ::proto::nav_api::VesselInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::VesselInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::GetVesselInfoRequest* Arena::CreateMaybeMessage< ::proto::nav_api::GetVesselInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::GetVesselInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::GetVesselInfoResponse* Arena::CreateMaybeMessage< ::proto::nav_api::GetVesselInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::GetVesselInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetDraftRequest* Arena::CreateMaybeMessage< ::proto::nav_api::SetDraftRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetDraftRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetDraftResponse* Arena::CreateMaybeMessage< ::proto::nav_api::SetDraftResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetDraftResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetKeelOffsetRequest* Arena::CreateMaybeMessage< ::proto::nav_api::SetKeelOffsetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetKeelOffsetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::nav_api::SetKeelOffsetResponse* Arena::CreateMaybeMessage< ::proto::nav_api::SetKeelOffsetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::nav_api::SetKeelOffsetResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
