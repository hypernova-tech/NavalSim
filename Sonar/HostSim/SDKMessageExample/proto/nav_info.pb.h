// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nav_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_nav_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_nav_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "nmea.pb.h"
#include "time.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_nav_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_nav_5finfo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace proto {
namespace nav_info {
class CourseOverGround;
struct CourseOverGroundDefaultTypeInternal;
extern CourseOverGroundDefaultTypeInternal _CourseOverGround_default_instance_;
class Depth;
struct DepthDefaultTypeInternal;
extern DepthDefaultTypeInternal _Depth_default_instance_;
class DualSpeed;
struct DualSpeedDefaultTypeInternal;
extern DualSpeedDefaultTypeInternal _DualSpeed_default_instance_;
class FilteredState;
struct FilteredStateDefaultTypeInternal;
extern FilteredStateDefaultTypeInternal _FilteredState_default_instance_;
class Heading;
struct HeadingDefaultTypeInternal;
extern HeadingDefaultTypeInternal _Heading_default_instance_;
class LocalTime;
struct LocalTimeDefaultTypeInternal;
extern LocalTimeDefaultTypeInternal _LocalTime_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class RateOfTurn;
struct RateOfTurnDefaultTypeInternal;
extern RateOfTurnDefaultTypeInternal _RateOfTurn_default_instance_;
class Speed;
struct SpeedDefaultTypeInternal;
extern SpeedDefaultTypeInternal _Speed_default_instance_;
class UTCTime;
struct UTCTimeDefaultTypeInternal;
extern UTCTimeDefaultTypeInternal _UTCTime_default_instance_;
}  // namespace nav_info
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::nav_info::CourseOverGround* Arena::CreateMaybeMessage<::proto::nav_info::CourseOverGround>(Arena*);
template<> ::proto::nav_info::Depth* Arena::CreateMaybeMessage<::proto::nav_info::Depth>(Arena*);
template<> ::proto::nav_info::DualSpeed* Arena::CreateMaybeMessage<::proto::nav_info::DualSpeed>(Arena*);
template<> ::proto::nav_info::FilteredState* Arena::CreateMaybeMessage<::proto::nav_info::FilteredState>(Arena*);
template<> ::proto::nav_info::Heading* Arena::CreateMaybeMessage<::proto::nav_info::Heading>(Arena*);
template<> ::proto::nav_info::LocalTime* Arena::CreateMaybeMessage<::proto::nav_info::LocalTime>(Arena*);
template<> ::proto::nav_info::Position* Arena::CreateMaybeMessage<::proto::nav_info::Position>(Arena*);
template<> ::proto::nav_info::RateOfTurn* Arena::CreateMaybeMessage<::proto::nav_info::RateOfTurn>(Arena*);
template<> ::proto::nav_info::Speed* Arena::CreateMaybeMessage<::proto::nav_info::Speed>(Arena*);
template<> ::proto::nav_info::UTCTime* Arena::CreateMaybeMessage<::proto::nav_info::UTCTime>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {
namespace nav_info {

enum Heading_Type : int {
  Heading_Type_OBSOLETE_kSensor = 0,
  Heading_Type_OBSOLETE_kMagnetic = 1,
  Heading_Type_kTrue = 2,
  Heading_Type_kManufactured = 3
};
bool Heading_Type_IsValid(int value);
constexpr Heading_Type Heading_Type_Type_MIN = Heading_Type_OBSOLETE_kSensor;
constexpr Heading_Type Heading_Type_Type_MAX = Heading_Type_kManufactured;
constexpr int Heading_Type_Type_ARRAYSIZE = Heading_Type_Type_MAX + 1;

const std::string& Heading_Type_Name(Heading_Type value);
template<typename T>
inline const std::string& Heading_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Heading_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Heading_Type_Name.");
  return Heading_Type_Name(static_cast<Heading_Type>(enum_t_value));
}
bool Heading_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Heading_Type* value);
// ===================================================================

class Depth final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.Depth) */ {
 public:
  inline Depth() : Depth(nullptr) {}
  ~Depth() override;
  explicit constexpr Depth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Depth(const Depth& from);
  Depth(Depth&& from) noexcept
    : Depth() {
    *this = ::std::move(from);
  }

  inline Depth& operator=(const Depth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Depth& operator=(Depth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Depth& default_instance() {
    return *internal_default_instance();
  }
  static inline const Depth* internal_default_instance() {
    return reinterpret_cast<const Depth*>(
               &_Depth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Depth& a, Depth& b) {
    a.Swap(&b);
  }
  inline void Swap(Depth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Depth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Depth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Depth>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Depth& from);
  void MergeFrom(const Depth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Depth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.Depth";
  }
  protected:
  explicit Depth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNmeaFieldNumber = 2,
    kDepthFieldNumber = 1,
  };
  // optional .proto.nmea.NmeaData nmea = 2;
  bool has_nmea() const;
  private:
  bool _internal_has_nmea() const;
  public:
  void clear_nmea();
  const ::proto::nmea::NmeaData& nmea() const;
  PROTOBUF_NODISCARD ::proto::nmea::NmeaData* release_nmea();
  ::proto::nmea::NmeaData* mutable_nmea();
  void set_allocated_nmea(::proto::nmea::NmeaData* nmea);
  private:
  const ::proto::nmea::NmeaData& _internal_nmea() const;
  ::proto::nmea::NmeaData* _internal_mutable_nmea();
  public:
  void unsafe_arena_set_allocated_nmea(
      ::proto::nmea::NmeaData* nmea);
  ::proto::nmea::NmeaData* unsafe_arena_release_nmea();

  // optional double depth = 1;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  double depth() const;
  void set_depth(double value);
  private:
  double _internal_depth() const;
  void _internal_set_depth(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_info.Depth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nmea::NmeaData* nmea_;
  double depth_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Heading final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.Heading) */ {
 public:
  inline Heading() : Heading(nullptr) {}
  ~Heading() override;
  explicit constexpr Heading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Heading(const Heading& from);
  Heading(Heading&& from) noexcept
    : Heading() {
    *this = ::std::move(from);
  }

  inline Heading& operator=(const Heading& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heading& operator=(Heading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Heading& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heading* internal_default_instance() {
    return reinterpret_cast<const Heading*>(
               &_Heading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Heading& a, Heading& b) {
    a.Swap(&b);
  }
  inline void Swap(Heading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heading* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Heading>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Heading& from);
  void MergeFrom(const Heading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Heading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.Heading";
  }
  protected:
  explicit Heading(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Heading_Type Type;
  static constexpr Type OBSOLETE_kSensor =
    Heading_Type_OBSOLETE_kSensor;
  static constexpr Type OBSOLETE_kMagnetic =
    Heading_Type_OBSOLETE_kMagnetic;
  static constexpr Type kTrue =
    Heading_Type_kTrue;
  static constexpr Type kManufactured =
    Heading_Type_kManufactured;
  static inline bool Type_IsValid(int value) {
    return Heading_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Heading_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Heading_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Heading_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Heading_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Heading_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNmeaFieldNumber = 3,
    kHeadingFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional .proto.nmea.NmeaData nmea = 3;
  bool has_nmea() const;
  private:
  bool _internal_has_nmea() const;
  public:
  void clear_nmea();
  const ::proto::nmea::NmeaData& nmea() const;
  PROTOBUF_NODISCARD ::proto::nmea::NmeaData* release_nmea();
  ::proto::nmea::NmeaData* mutable_nmea();
  void set_allocated_nmea(::proto::nmea::NmeaData* nmea);
  private:
  const ::proto::nmea::NmeaData& _internal_nmea() const;
  ::proto::nmea::NmeaData* _internal_mutable_nmea();
  public:
  void unsafe_arena_set_allocated_nmea(
      ::proto::nmea::NmeaData* nmea);
  ::proto::nmea::NmeaData* unsafe_arena_release_nmea();

  // optional double heading = 1;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // optional .proto.nav_info.Heading.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::proto::nav_info::Heading_Type type() const;
  void set_type(::proto::nav_info::Heading_Type value);
  private:
  ::proto::nav_info::Heading_Type _internal_type() const;
  void _internal_set_type(::proto::nav_info::Heading_Type value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_info.Heading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nmea::NmeaData* nmea_;
  double heading_;
  int type_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit constexpr Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNmeaFieldNumber = 7,
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
  };
  // optional .proto.nmea.NmeaData nmea = 7;
  bool has_nmea() const;
  private:
  bool _internal_has_nmea() const;
  public:
  void clear_nmea();
  const ::proto::nmea::NmeaData& nmea() const;
  PROTOBUF_NODISCARD ::proto::nmea::NmeaData* release_nmea();
  ::proto::nmea::NmeaData* mutable_nmea();
  void set_allocated_nmea(::proto::nmea::NmeaData* nmea);
  private:
  const ::proto::nmea::NmeaData& _internal_nmea() const;
  ::proto::nmea::NmeaData* _internal_mutable_nmea();
  public:
  void unsafe_arena_set_allocated_nmea(
      ::proto::nmea::NmeaData* nmea);
  ::proto::nmea::NmeaData* unsafe_arena_release_nmea();

  // optional double lat = 1;
  bool has_lat() const;
  private:
  bool _internal_has_lat() const;
  public:
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // optional double lon = 2;
  bool has_lon() const;
  private:
  bool _internal_has_lon() const;
  public:
  void clear_lon();
  double lon() const;
  void set_lon(double value);
  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_info.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nmea::NmeaData* nmea_;
  double lat_;
  double lon_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Speed final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.Speed) */ {
 public:
  inline Speed() : Speed(nullptr) {}
  ~Speed() override;
  explicit constexpr Speed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Speed(const Speed& from);
  Speed(Speed&& from) noexcept
    : Speed() {
    *this = ::std::move(from);
  }

  inline Speed& operator=(const Speed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Speed& operator=(Speed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Speed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Speed* internal_default_instance() {
    return reinterpret_cast<const Speed*>(
               &_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Speed& a, Speed& b) {
    a.Swap(&b);
  }
  inline void Swap(Speed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Speed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Speed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Speed>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Speed& from);
  void MergeFrom(const Speed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Speed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.Speed";
  }
  protected:
  explicit Speed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNmeaFieldNumber = 2,
    kSpeedFieldNumber = 1,
  };
  // optional .proto.nmea.NmeaData nmea = 2;
  bool has_nmea() const;
  private:
  bool _internal_has_nmea() const;
  public:
  void clear_nmea();
  const ::proto::nmea::NmeaData& nmea() const;
  PROTOBUF_NODISCARD ::proto::nmea::NmeaData* release_nmea();
  ::proto::nmea::NmeaData* mutable_nmea();
  void set_allocated_nmea(::proto::nmea::NmeaData* nmea);
  private:
  const ::proto::nmea::NmeaData& _internal_nmea() const;
  ::proto::nmea::NmeaData* _internal_mutable_nmea();
  public:
  void unsafe_arena_set_allocated_nmea(
      ::proto::nmea::NmeaData* nmea);
  ::proto::nmea::NmeaData* unsafe_arena_release_nmea();

  // optional double speed = 1;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_info.Speed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nmea::NmeaData* nmea_;
  double speed_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class DualSpeed final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.DualSpeed) */ {
 public:
  inline DualSpeed() : DualSpeed(nullptr) {}
  ~DualSpeed() override;
  explicit constexpr DualSpeed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DualSpeed(const DualSpeed& from);
  DualSpeed(DualSpeed&& from) noexcept
    : DualSpeed() {
    *this = ::std::move(from);
  }

  inline DualSpeed& operator=(const DualSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline DualSpeed& operator=(DualSpeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DualSpeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const DualSpeed* internal_default_instance() {
    return reinterpret_cast<const DualSpeed*>(
               &_DualSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DualSpeed& a, DualSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(DualSpeed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DualSpeed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DualSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DualSpeed>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DualSpeed& from);
  void MergeFrom(const DualSpeed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DualSpeed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.DualSpeed";
  }
  protected:
  explicit DualSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNmeaFieldNumber = 3,
    kGroundTransversalFieldNumber = 1,
    kGroundLongitudinalFieldNumber = 2,
  };
  // optional .proto.nmea.NmeaData nmea = 3;
  bool has_nmea() const;
  private:
  bool _internal_has_nmea() const;
  public:
  void clear_nmea();
  const ::proto::nmea::NmeaData& nmea() const;
  PROTOBUF_NODISCARD ::proto::nmea::NmeaData* release_nmea();
  ::proto::nmea::NmeaData* mutable_nmea();
  void set_allocated_nmea(::proto::nmea::NmeaData* nmea);
  private:
  const ::proto::nmea::NmeaData& _internal_nmea() const;
  ::proto::nmea::NmeaData* _internal_mutable_nmea();
  public:
  void unsafe_arena_set_allocated_nmea(
      ::proto::nmea::NmeaData* nmea);
  ::proto::nmea::NmeaData* unsafe_arena_release_nmea();

  // optional float ground_transversal = 1;
  bool has_ground_transversal() const;
  private:
  bool _internal_has_ground_transversal() const;
  public:
  void clear_ground_transversal();
  float ground_transversal() const;
  void set_ground_transversal(float value);
  private:
  float _internal_ground_transversal() const;
  void _internal_set_ground_transversal(float value);
  public:

  // optional float ground_longitudinal = 2;
  bool has_ground_longitudinal() const;
  private:
  bool _internal_has_ground_longitudinal() const;
  public:
  void clear_ground_longitudinal();
  float ground_longitudinal() const;
  void set_ground_longitudinal(float value);
  private:
  float _internal_ground_longitudinal() const;
  void _internal_set_ground_longitudinal(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_info.DualSpeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nmea::NmeaData* nmea_;
  float ground_transversal_;
  float ground_longitudinal_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RateOfTurn final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.RateOfTurn) */ {
 public:
  inline RateOfTurn() : RateOfTurn(nullptr) {}
  ~RateOfTurn() override;
  explicit constexpr RateOfTurn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RateOfTurn(const RateOfTurn& from);
  RateOfTurn(RateOfTurn&& from) noexcept
    : RateOfTurn() {
    *this = ::std::move(from);
  }

  inline RateOfTurn& operator=(const RateOfTurn& from) {
    CopyFrom(from);
    return *this;
  }
  inline RateOfTurn& operator=(RateOfTurn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RateOfTurn& default_instance() {
    return *internal_default_instance();
  }
  static inline const RateOfTurn* internal_default_instance() {
    return reinterpret_cast<const RateOfTurn*>(
               &_RateOfTurn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RateOfTurn& a, RateOfTurn& b) {
    a.Swap(&b);
  }
  inline void Swap(RateOfTurn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RateOfTurn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RateOfTurn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RateOfTurn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RateOfTurn& from);
  void MergeFrom(const RateOfTurn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RateOfTurn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.RateOfTurn";
  }
  protected:
  explicit RateOfTurn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNmeaFieldNumber = 2,
    kRotFieldNumber = 1,
  };
  // optional .proto.nmea.NmeaData nmea = 2;
  bool has_nmea() const;
  private:
  bool _internal_has_nmea() const;
  public:
  void clear_nmea();
  const ::proto::nmea::NmeaData& nmea() const;
  PROTOBUF_NODISCARD ::proto::nmea::NmeaData* release_nmea();
  ::proto::nmea::NmeaData* mutable_nmea();
  void set_allocated_nmea(::proto::nmea::NmeaData* nmea);
  private:
  const ::proto::nmea::NmeaData& _internal_nmea() const;
  ::proto::nmea::NmeaData* _internal_mutable_nmea();
  public:
  void unsafe_arena_set_allocated_nmea(
      ::proto::nmea::NmeaData* nmea);
  ::proto::nmea::NmeaData* unsafe_arena_release_nmea();

  // optional float rot = 1;
  bool has_rot() const;
  private:
  bool _internal_has_rot() const;
  public:
  void clear_rot();
  float rot() const;
  void set_rot(float value);
  private:
  float _internal_rot() const;
  void _internal_set_rot(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_info.RateOfTurn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nmea::NmeaData* nmea_;
  float rot_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class CourseOverGround final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.CourseOverGround) */ {
 public:
  inline CourseOverGround() : CourseOverGround(nullptr) {}
  ~CourseOverGround() override;
  explicit constexpr CourseOverGround(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CourseOverGround(const CourseOverGround& from);
  CourseOverGround(CourseOverGround&& from) noexcept
    : CourseOverGround() {
    *this = ::std::move(from);
  }

  inline CourseOverGround& operator=(const CourseOverGround& from) {
    CopyFrom(from);
    return *this;
  }
  inline CourseOverGround& operator=(CourseOverGround&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CourseOverGround& default_instance() {
    return *internal_default_instance();
  }
  static inline const CourseOverGround* internal_default_instance() {
    return reinterpret_cast<const CourseOverGround*>(
               &_CourseOverGround_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CourseOverGround& a, CourseOverGround& b) {
    a.Swap(&b);
  }
  inline void Swap(CourseOverGround* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CourseOverGround* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CourseOverGround* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CourseOverGround>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CourseOverGround& from);
  void MergeFrom(const CourseOverGround& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CourseOverGround* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.CourseOverGround";
  }
  protected:
  explicit CourseOverGround(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNmeaFieldNumber = 2,
    kTrueHeadingFieldNumber = 1,
  };
  // optional .proto.nmea.NmeaData nmea = 2;
  bool has_nmea() const;
  private:
  bool _internal_has_nmea() const;
  public:
  void clear_nmea();
  const ::proto::nmea::NmeaData& nmea() const;
  PROTOBUF_NODISCARD ::proto::nmea::NmeaData* release_nmea();
  ::proto::nmea::NmeaData* mutable_nmea();
  void set_allocated_nmea(::proto::nmea::NmeaData* nmea);
  private:
  const ::proto::nmea::NmeaData& _internal_nmea() const;
  ::proto::nmea::NmeaData* _internal_mutable_nmea();
  public:
  void unsafe_arena_set_allocated_nmea(
      ::proto::nmea::NmeaData* nmea);
  ::proto::nmea::NmeaData* unsafe_arena_release_nmea();

  // optional float true_heading = 1;
  bool has_true_heading() const;
  private:
  bool _internal_has_true_heading() const;
  public:
  void clear_true_heading();
  float true_heading() const;
  void set_true_heading(float value);
  private:
  float _internal_true_heading() const;
  void _internal_set_true_heading(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_info.CourseOverGround)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nmea::NmeaData* nmea_;
  float true_heading_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class UTCTime final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.UTCTime) */ {
 public:
  inline UTCTime() : UTCTime(nullptr) {}
  ~UTCTime() override;
  explicit constexpr UTCTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UTCTime(const UTCTime& from);
  UTCTime(UTCTime&& from) noexcept
    : UTCTime() {
    *this = ::std::move(from);
  }

  inline UTCTime& operator=(const UTCTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline UTCTime& operator=(UTCTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UTCTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const UTCTime* internal_default_instance() {
    return reinterpret_cast<const UTCTime*>(
               &_UTCTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UTCTime& a, UTCTime& b) {
    a.Swap(&b);
  }
  inline void Swap(UTCTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UTCTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UTCTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UTCTime>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UTCTime& from);
  void MergeFrom(const UTCTime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UTCTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.UTCTime";
  }
  protected:
  explicit UTCTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // optional .proto.time.Time time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::proto::time::Time& time() const;
  PROTOBUF_NODISCARD ::proto::time::Time* release_time();
  ::proto::time::Time* mutable_time();
  void set_allocated_time(::proto::time::Time* time);
  private:
  const ::proto::time::Time& _internal_time() const;
  ::proto::time::Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::proto::time::Time* time);
  ::proto::time::Time* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:proto.nav_info.UTCTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::time::Time* time_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class LocalTime final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.LocalTime) */ {
 public:
  inline LocalTime() : LocalTime(nullptr) {}
  ~LocalTime() override;
  explicit constexpr LocalTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTime(const LocalTime& from);
  LocalTime(LocalTime&& from) noexcept
    : LocalTime() {
    *this = ::std::move(from);
  }

  inline LocalTime& operator=(const LocalTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTime& operator=(LocalTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LocalTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTime* internal_default_instance() {
    return reinterpret_cast<const LocalTime*>(
               &_LocalTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LocalTime& a, LocalTime& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalTime>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocalTime& from);
  void MergeFrom(const LocalTime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.LocalTime";
  }
  protected:
  explicit LocalTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // optional .proto.time.Time time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::proto::time::Time& time() const;
  PROTOBUF_NODISCARD ::proto::time::Time* release_time();
  ::proto::time::Time* mutable_time();
  void set_allocated_time(::proto::time::Time* time);
  private:
  const ::proto::time::Time& _internal_time() const;
  ::proto::time::Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::proto::time::Time* time);
  ::proto::time::Time* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:proto.nav_info.LocalTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::time::Time* time_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// -------------------------------------------------------------------

class FilteredState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_info.FilteredState) */ {
 public:
  inline FilteredState() : FilteredState(nullptr) {}
  ~FilteredState() override;
  explicit constexpr FilteredState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilteredState(const FilteredState& from);
  FilteredState(FilteredState&& from) noexcept
    : FilteredState() {
    *this = ::std::move(from);
  }

  inline FilteredState& operator=(const FilteredState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilteredState& operator=(FilteredState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FilteredState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilteredState* internal_default_instance() {
    return reinterpret_cast<const FilteredState*>(
               &_FilteredState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FilteredState& a, FilteredState& b) {
    a.Swap(&b);
  }
  inline void Swap(FilteredState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilteredState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilteredState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilteredState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FilteredState& from);
  void MergeFrom(const FilteredState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FilteredState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_info.FilteredState";
  }
  protected:
  explicit FilteredState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 7,
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kHeadingFieldNumber = 4,
    kCourseFieldNumber = 5,
    kRotFieldNumber = 6,
    kFilterEnabledFieldNumber = 8,
    kLatlonIsFilteredFieldNumber = 9,
    kHeadingIsFilteredFieldNumber = 10,
  };
  // optional .proto.time.Time time = 7;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::proto::time::Time& time() const;
  PROTOBUF_NODISCARD ::proto::time::Time* release_time();
  ::proto::time::Time* mutable_time();
  void set_allocated_time(::proto::time::Time* time);
  private:
  const ::proto::time::Time& _internal_time() const;
  ::proto::time::Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::proto::time::Time* time);
  ::proto::time::Time* unsafe_arena_release_time();

  // optional double lat = 1;
  bool has_lat() const;
  private:
  bool _internal_has_lat() const;
  public:
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // optional double lon = 2;
  bool has_lon() const;
  private:
  bool _internal_has_lon() const;
  public:
  void clear_lon();
  double lon() const;
  void set_lon(double value);
  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);
  public:

  // optional double speed = 3;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // optional double heading = 4;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // optional double course = 5;
  bool has_course() const;
  private:
  bool _internal_has_course() const;
  public:
  void clear_course();
  double course() const;
  void set_course(double value);
  private:
  double _internal_course() const;
  void _internal_set_course(double value);
  public:

  // optional double rot = 6;
  bool has_rot() const;
  private:
  bool _internal_has_rot() const;
  public:
  void clear_rot();
  double rot() const;
  void set_rot(double value);
  private:
  double _internal_rot() const;
  void _internal_set_rot(double value);
  public:

  // optional bool filter_enabled = 8;
  bool has_filter_enabled() const;
  private:
  bool _internal_has_filter_enabled() const;
  public:
  void clear_filter_enabled();
  bool filter_enabled() const;
  void set_filter_enabled(bool value);
  private:
  bool _internal_filter_enabled() const;
  void _internal_set_filter_enabled(bool value);
  public:

  // optional bool latlon_is_filtered = 9;
  bool has_latlon_is_filtered() const;
  private:
  bool _internal_has_latlon_is_filtered() const;
  public:
  void clear_latlon_is_filtered();
  bool latlon_is_filtered() const;
  void set_latlon_is_filtered(bool value);
  private:
  bool _internal_latlon_is_filtered() const;
  void _internal_set_latlon_is_filtered(bool value);
  public:

  // optional bool heading_is_filtered = 10;
  bool has_heading_is_filtered() const;
  private:
  bool _internal_has_heading_is_filtered() const;
  public:
  void clear_heading_is_filtered();
  bool heading_is_filtered() const;
  void set_heading_is_filtered(bool value);
  private:
  bool _internal_heading_is_filtered() const;
  void _internal_set_heading_is_filtered(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_info.FilteredState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::time::Time* time_;
  double lat_;
  double lon_;
  double speed_;
  double heading_;
  double course_;
  double rot_;
  bool filter_enabled_;
  bool latlon_is_filtered_;
  bool heading_is_filtered_;
  friend struct ::TableStruct_nav_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Depth

// optional double depth = 1;
inline bool Depth::_internal_has_depth() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Depth::has_depth() const {
  return _internal_has_depth();
}
inline void Depth::clear_depth() {
  depth_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Depth::_internal_depth() const {
  return depth_;
}
inline double Depth::depth() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Depth.depth)
  return _internal_depth();
}
inline void Depth::_internal_set_depth(double value) {
  _has_bits_[0] |= 0x00000002u;
  depth_ = value;
}
inline void Depth::set_depth(double value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.Depth.depth)
}

// optional .proto.nmea.NmeaData nmea = 2;
inline bool Depth::_internal_has_nmea() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nmea_ != nullptr);
  return value;
}
inline bool Depth::has_nmea() const {
  return _internal_has_nmea();
}
inline const ::proto::nmea::NmeaData& Depth::_internal_nmea() const {
  const ::proto::nmea::NmeaData* p = nmea_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nmea::NmeaData&>(
      ::proto::nmea::_NmeaData_default_instance_);
}
inline const ::proto::nmea::NmeaData& Depth::nmea() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Depth.nmea)
  return _internal_nmea();
}
inline void Depth::unsafe_arena_set_allocated_nmea(
    ::proto::nmea::NmeaData* nmea) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  nmea_ = nmea;
  if (nmea) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.Depth.nmea)
}
inline ::proto::nmea::NmeaData* Depth::release_nmea() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nmea::NmeaData* Depth::unsafe_arena_release_nmea() {
  // @@protoc_insertion_point(field_release:proto.nav_info.Depth.nmea)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
  return temp;
}
inline ::proto::nmea::NmeaData* Depth::_internal_mutable_nmea() {
  _has_bits_[0] |= 0x00000001u;
  if (nmea_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nmea::NmeaData>(GetArenaForAllocation());
    nmea_ = p;
  }
  return nmea_;
}
inline ::proto::nmea::NmeaData* Depth::mutable_nmea() {
  ::proto::nmea::NmeaData* _msg = _internal_mutable_nmea();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.Depth.nmea)
  return _msg;
}
inline void Depth::set_allocated_nmea(::proto::nmea::NmeaData* nmea) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  if (nmea) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea));
    if (message_arena != submessage_arena) {
      nmea = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nmea, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nmea_ = nmea;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.Depth.nmea)
}

// -------------------------------------------------------------------

// Heading

// optional double heading = 1;
inline bool Heading::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Heading::has_heading() const {
  return _internal_has_heading();
}
inline void Heading::clear_heading() {
  heading_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Heading::_internal_heading() const {
  return heading_;
}
inline double Heading::heading() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Heading.heading)
  return _internal_heading();
}
inline void Heading::_internal_set_heading(double value) {
  _has_bits_[0] |= 0x00000002u;
  heading_ = value;
}
inline void Heading::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.Heading.heading)
}

// optional .proto.nav_info.Heading.Type type = 2;
inline bool Heading::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Heading::has_type() const {
  return _internal_has_type();
}
inline void Heading::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::nav_info::Heading_Type Heading::_internal_type() const {
  return static_cast< ::proto::nav_info::Heading_Type >(type_);
}
inline ::proto::nav_info::Heading_Type Heading::type() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Heading.type)
  return _internal_type();
}
inline void Heading::_internal_set_type(::proto::nav_info::Heading_Type value) {
  assert(::proto::nav_info::Heading_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void Heading::set_type(::proto::nav_info::Heading_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.Heading.type)
}

// optional .proto.nmea.NmeaData nmea = 3;
inline bool Heading::_internal_has_nmea() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nmea_ != nullptr);
  return value;
}
inline bool Heading::has_nmea() const {
  return _internal_has_nmea();
}
inline const ::proto::nmea::NmeaData& Heading::_internal_nmea() const {
  const ::proto::nmea::NmeaData* p = nmea_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nmea::NmeaData&>(
      ::proto::nmea::_NmeaData_default_instance_);
}
inline const ::proto::nmea::NmeaData& Heading::nmea() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Heading.nmea)
  return _internal_nmea();
}
inline void Heading::unsafe_arena_set_allocated_nmea(
    ::proto::nmea::NmeaData* nmea) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  nmea_ = nmea;
  if (nmea) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.Heading.nmea)
}
inline ::proto::nmea::NmeaData* Heading::release_nmea() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nmea::NmeaData* Heading::unsafe_arena_release_nmea() {
  // @@protoc_insertion_point(field_release:proto.nav_info.Heading.nmea)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
  return temp;
}
inline ::proto::nmea::NmeaData* Heading::_internal_mutable_nmea() {
  _has_bits_[0] |= 0x00000001u;
  if (nmea_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nmea::NmeaData>(GetArenaForAllocation());
    nmea_ = p;
  }
  return nmea_;
}
inline ::proto::nmea::NmeaData* Heading::mutable_nmea() {
  ::proto::nmea::NmeaData* _msg = _internal_mutable_nmea();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.Heading.nmea)
  return _msg;
}
inline void Heading::set_allocated_nmea(::proto::nmea::NmeaData* nmea) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  if (nmea) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea));
    if (message_arena != submessage_arena) {
      nmea = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nmea, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nmea_ = nmea;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.Heading.nmea)
}

// -------------------------------------------------------------------

// Position

// optional double lat = 1;
inline bool Position::_internal_has_lat() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Position::has_lat() const {
  return _internal_has_lat();
}
inline void Position::clear_lat() {
  lat_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Position::_internal_lat() const {
  return lat_;
}
inline double Position::lat() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Position.lat)
  return _internal_lat();
}
inline void Position::_internal_set_lat(double value) {
  _has_bits_[0] |= 0x00000002u;
  lat_ = value;
}
inline void Position::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.Position.lat)
}

// optional double lon = 2;
inline bool Position::_internal_has_lon() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Position::has_lon() const {
  return _internal_has_lon();
}
inline void Position::clear_lon() {
  lon_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Position::_internal_lon() const {
  return lon_;
}
inline double Position::lon() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Position.lon)
  return _internal_lon();
}
inline void Position::_internal_set_lon(double value) {
  _has_bits_[0] |= 0x00000004u;
  lon_ = value;
}
inline void Position::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.Position.lon)
}

// optional .proto.nmea.NmeaData nmea = 7;
inline bool Position::_internal_has_nmea() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nmea_ != nullptr);
  return value;
}
inline bool Position::has_nmea() const {
  return _internal_has_nmea();
}
inline const ::proto::nmea::NmeaData& Position::_internal_nmea() const {
  const ::proto::nmea::NmeaData* p = nmea_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nmea::NmeaData&>(
      ::proto::nmea::_NmeaData_default_instance_);
}
inline const ::proto::nmea::NmeaData& Position::nmea() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Position.nmea)
  return _internal_nmea();
}
inline void Position::unsafe_arena_set_allocated_nmea(
    ::proto::nmea::NmeaData* nmea) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  nmea_ = nmea;
  if (nmea) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.Position.nmea)
}
inline ::proto::nmea::NmeaData* Position::release_nmea() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nmea::NmeaData* Position::unsafe_arena_release_nmea() {
  // @@protoc_insertion_point(field_release:proto.nav_info.Position.nmea)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
  return temp;
}
inline ::proto::nmea::NmeaData* Position::_internal_mutable_nmea() {
  _has_bits_[0] |= 0x00000001u;
  if (nmea_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nmea::NmeaData>(GetArenaForAllocation());
    nmea_ = p;
  }
  return nmea_;
}
inline ::proto::nmea::NmeaData* Position::mutable_nmea() {
  ::proto::nmea::NmeaData* _msg = _internal_mutable_nmea();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.Position.nmea)
  return _msg;
}
inline void Position::set_allocated_nmea(::proto::nmea::NmeaData* nmea) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  if (nmea) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea));
    if (message_arena != submessage_arena) {
      nmea = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nmea, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nmea_ = nmea;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.Position.nmea)
}

// -------------------------------------------------------------------

// Speed

// optional double speed = 1;
inline bool Speed::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Speed::has_speed() const {
  return _internal_has_speed();
}
inline void Speed::clear_speed() {
  speed_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Speed::_internal_speed() const {
  return speed_;
}
inline double Speed::speed() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Speed.speed)
  return _internal_speed();
}
inline void Speed::_internal_set_speed(double value) {
  _has_bits_[0] |= 0x00000002u;
  speed_ = value;
}
inline void Speed::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.Speed.speed)
}

// optional .proto.nmea.NmeaData nmea = 2;
inline bool Speed::_internal_has_nmea() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nmea_ != nullptr);
  return value;
}
inline bool Speed::has_nmea() const {
  return _internal_has_nmea();
}
inline const ::proto::nmea::NmeaData& Speed::_internal_nmea() const {
  const ::proto::nmea::NmeaData* p = nmea_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nmea::NmeaData&>(
      ::proto::nmea::_NmeaData_default_instance_);
}
inline const ::proto::nmea::NmeaData& Speed::nmea() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.Speed.nmea)
  return _internal_nmea();
}
inline void Speed::unsafe_arena_set_allocated_nmea(
    ::proto::nmea::NmeaData* nmea) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  nmea_ = nmea;
  if (nmea) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.Speed.nmea)
}
inline ::proto::nmea::NmeaData* Speed::release_nmea() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nmea::NmeaData* Speed::unsafe_arena_release_nmea() {
  // @@protoc_insertion_point(field_release:proto.nav_info.Speed.nmea)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
  return temp;
}
inline ::proto::nmea::NmeaData* Speed::_internal_mutable_nmea() {
  _has_bits_[0] |= 0x00000001u;
  if (nmea_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nmea::NmeaData>(GetArenaForAllocation());
    nmea_ = p;
  }
  return nmea_;
}
inline ::proto::nmea::NmeaData* Speed::mutable_nmea() {
  ::proto::nmea::NmeaData* _msg = _internal_mutable_nmea();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.Speed.nmea)
  return _msg;
}
inline void Speed::set_allocated_nmea(::proto::nmea::NmeaData* nmea) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  if (nmea) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea));
    if (message_arena != submessage_arena) {
      nmea = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nmea, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nmea_ = nmea;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.Speed.nmea)
}

// -------------------------------------------------------------------

// DualSpeed

// optional float ground_transversal = 1;
inline bool DualSpeed::_internal_has_ground_transversal() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DualSpeed::has_ground_transversal() const {
  return _internal_has_ground_transversal();
}
inline void DualSpeed::clear_ground_transversal() {
  ground_transversal_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float DualSpeed::_internal_ground_transversal() const {
  return ground_transversal_;
}
inline float DualSpeed::ground_transversal() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.DualSpeed.ground_transversal)
  return _internal_ground_transversal();
}
inline void DualSpeed::_internal_set_ground_transversal(float value) {
  _has_bits_[0] |= 0x00000002u;
  ground_transversal_ = value;
}
inline void DualSpeed::set_ground_transversal(float value) {
  _internal_set_ground_transversal(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.DualSpeed.ground_transversal)
}

// optional float ground_longitudinal = 2;
inline bool DualSpeed::_internal_has_ground_longitudinal() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DualSpeed::has_ground_longitudinal() const {
  return _internal_has_ground_longitudinal();
}
inline void DualSpeed::clear_ground_longitudinal() {
  ground_longitudinal_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float DualSpeed::_internal_ground_longitudinal() const {
  return ground_longitudinal_;
}
inline float DualSpeed::ground_longitudinal() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.DualSpeed.ground_longitudinal)
  return _internal_ground_longitudinal();
}
inline void DualSpeed::_internal_set_ground_longitudinal(float value) {
  _has_bits_[0] |= 0x00000004u;
  ground_longitudinal_ = value;
}
inline void DualSpeed::set_ground_longitudinal(float value) {
  _internal_set_ground_longitudinal(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.DualSpeed.ground_longitudinal)
}

// optional .proto.nmea.NmeaData nmea = 3;
inline bool DualSpeed::_internal_has_nmea() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nmea_ != nullptr);
  return value;
}
inline bool DualSpeed::has_nmea() const {
  return _internal_has_nmea();
}
inline const ::proto::nmea::NmeaData& DualSpeed::_internal_nmea() const {
  const ::proto::nmea::NmeaData* p = nmea_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nmea::NmeaData&>(
      ::proto::nmea::_NmeaData_default_instance_);
}
inline const ::proto::nmea::NmeaData& DualSpeed::nmea() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.DualSpeed.nmea)
  return _internal_nmea();
}
inline void DualSpeed::unsafe_arena_set_allocated_nmea(
    ::proto::nmea::NmeaData* nmea) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  nmea_ = nmea;
  if (nmea) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.DualSpeed.nmea)
}
inline ::proto::nmea::NmeaData* DualSpeed::release_nmea() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nmea::NmeaData* DualSpeed::unsafe_arena_release_nmea() {
  // @@protoc_insertion_point(field_release:proto.nav_info.DualSpeed.nmea)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
  return temp;
}
inline ::proto::nmea::NmeaData* DualSpeed::_internal_mutable_nmea() {
  _has_bits_[0] |= 0x00000001u;
  if (nmea_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nmea::NmeaData>(GetArenaForAllocation());
    nmea_ = p;
  }
  return nmea_;
}
inline ::proto::nmea::NmeaData* DualSpeed::mutable_nmea() {
  ::proto::nmea::NmeaData* _msg = _internal_mutable_nmea();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.DualSpeed.nmea)
  return _msg;
}
inline void DualSpeed::set_allocated_nmea(::proto::nmea::NmeaData* nmea) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  if (nmea) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea));
    if (message_arena != submessage_arena) {
      nmea = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nmea, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nmea_ = nmea;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.DualSpeed.nmea)
}

// -------------------------------------------------------------------

// RateOfTurn

// optional float rot = 1;
inline bool RateOfTurn::_internal_has_rot() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RateOfTurn::has_rot() const {
  return _internal_has_rot();
}
inline void RateOfTurn::clear_rot() {
  rot_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float RateOfTurn::_internal_rot() const {
  return rot_;
}
inline float RateOfTurn::rot() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.RateOfTurn.rot)
  return _internal_rot();
}
inline void RateOfTurn::_internal_set_rot(float value) {
  _has_bits_[0] |= 0x00000002u;
  rot_ = value;
}
inline void RateOfTurn::set_rot(float value) {
  _internal_set_rot(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.RateOfTurn.rot)
}

// optional .proto.nmea.NmeaData nmea = 2;
inline bool RateOfTurn::_internal_has_nmea() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nmea_ != nullptr);
  return value;
}
inline bool RateOfTurn::has_nmea() const {
  return _internal_has_nmea();
}
inline const ::proto::nmea::NmeaData& RateOfTurn::_internal_nmea() const {
  const ::proto::nmea::NmeaData* p = nmea_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nmea::NmeaData&>(
      ::proto::nmea::_NmeaData_default_instance_);
}
inline const ::proto::nmea::NmeaData& RateOfTurn::nmea() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.RateOfTurn.nmea)
  return _internal_nmea();
}
inline void RateOfTurn::unsafe_arena_set_allocated_nmea(
    ::proto::nmea::NmeaData* nmea) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  nmea_ = nmea;
  if (nmea) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.RateOfTurn.nmea)
}
inline ::proto::nmea::NmeaData* RateOfTurn::release_nmea() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nmea::NmeaData* RateOfTurn::unsafe_arena_release_nmea() {
  // @@protoc_insertion_point(field_release:proto.nav_info.RateOfTurn.nmea)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
  return temp;
}
inline ::proto::nmea::NmeaData* RateOfTurn::_internal_mutable_nmea() {
  _has_bits_[0] |= 0x00000001u;
  if (nmea_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nmea::NmeaData>(GetArenaForAllocation());
    nmea_ = p;
  }
  return nmea_;
}
inline ::proto::nmea::NmeaData* RateOfTurn::mutable_nmea() {
  ::proto::nmea::NmeaData* _msg = _internal_mutable_nmea();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.RateOfTurn.nmea)
  return _msg;
}
inline void RateOfTurn::set_allocated_nmea(::proto::nmea::NmeaData* nmea) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  if (nmea) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea));
    if (message_arena != submessage_arena) {
      nmea = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nmea, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nmea_ = nmea;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.RateOfTurn.nmea)
}

// -------------------------------------------------------------------

// CourseOverGround

// optional float true_heading = 1;
inline bool CourseOverGround::_internal_has_true_heading() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CourseOverGround::has_true_heading() const {
  return _internal_has_true_heading();
}
inline void CourseOverGround::clear_true_heading() {
  true_heading_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CourseOverGround::_internal_true_heading() const {
  return true_heading_;
}
inline float CourseOverGround::true_heading() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.CourseOverGround.true_heading)
  return _internal_true_heading();
}
inline void CourseOverGround::_internal_set_true_heading(float value) {
  _has_bits_[0] |= 0x00000002u;
  true_heading_ = value;
}
inline void CourseOverGround::set_true_heading(float value) {
  _internal_set_true_heading(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.CourseOverGround.true_heading)
}

// optional .proto.nmea.NmeaData nmea = 2;
inline bool CourseOverGround::_internal_has_nmea() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nmea_ != nullptr);
  return value;
}
inline bool CourseOverGround::has_nmea() const {
  return _internal_has_nmea();
}
inline const ::proto::nmea::NmeaData& CourseOverGround::_internal_nmea() const {
  const ::proto::nmea::NmeaData* p = nmea_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nmea::NmeaData&>(
      ::proto::nmea::_NmeaData_default_instance_);
}
inline const ::proto::nmea::NmeaData& CourseOverGround::nmea() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.CourseOverGround.nmea)
  return _internal_nmea();
}
inline void CourseOverGround::unsafe_arena_set_allocated_nmea(
    ::proto::nmea::NmeaData* nmea) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  nmea_ = nmea;
  if (nmea) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.CourseOverGround.nmea)
}
inline ::proto::nmea::NmeaData* CourseOverGround::release_nmea() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nmea::NmeaData* CourseOverGround::unsafe_arena_release_nmea() {
  // @@protoc_insertion_point(field_release:proto.nav_info.CourseOverGround.nmea)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nmea::NmeaData* temp = nmea_;
  nmea_ = nullptr;
  return temp;
}
inline ::proto::nmea::NmeaData* CourseOverGround::_internal_mutable_nmea() {
  _has_bits_[0] |= 0x00000001u;
  if (nmea_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nmea::NmeaData>(GetArenaForAllocation());
    nmea_ = p;
  }
  return nmea_;
}
inline ::proto::nmea::NmeaData* CourseOverGround::mutable_nmea() {
  ::proto::nmea::NmeaData* _msg = _internal_mutable_nmea();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.CourseOverGround.nmea)
  return _msg;
}
inline void CourseOverGround::set_allocated_nmea(::proto::nmea::NmeaData* nmea) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea_);
  }
  if (nmea) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nmea));
    if (message_arena != submessage_arena) {
      nmea = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nmea, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nmea_ = nmea;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.CourseOverGround.nmea)
}

// -------------------------------------------------------------------

// UTCTime

// optional .proto.time.Time time = 1;
inline bool UTCTime::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool UTCTime::has_time() const {
  return _internal_has_time();
}
inline const ::proto::time::Time& UTCTime::_internal_time() const {
  const ::proto::time::Time* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::time::Time&>(
      ::proto::time::_Time_default_instance_);
}
inline const ::proto::time::Time& UTCTime::time() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.UTCTime.time)
  return _internal_time();
}
inline void UTCTime::unsafe_arena_set_allocated_time(
    ::proto::time::Time* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.UTCTime.time)
}
inline ::proto::time::Time* UTCTime::release_time() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::time::Time* UTCTime::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:proto.nav_info.UTCTime.time)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::proto::time::Time* UTCTime::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000001u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::time::Time>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::proto::time::Time* UTCTime::mutable_time() {
  ::proto::time::Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.UTCTime.time)
  return _msg;
}
inline void UTCTime::set_allocated_time(::proto::time::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.UTCTime.time)
}

// -------------------------------------------------------------------

// LocalTime

// optional .proto.time.Time time = 1;
inline bool LocalTime::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool LocalTime::has_time() const {
  return _internal_has_time();
}
inline const ::proto::time::Time& LocalTime::_internal_time() const {
  const ::proto::time::Time* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::time::Time&>(
      ::proto::time::_Time_default_instance_);
}
inline const ::proto::time::Time& LocalTime::time() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.LocalTime.time)
  return _internal_time();
}
inline void LocalTime::unsafe_arena_set_allocated_time(
    ::proto::time::Time* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.LocalTime.time)
}
inline ::proto::time::Time* LocalTime::release_time() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::time::Time* LocalTime::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:proto.nav_info.LocalTime.time)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::proto::time::Time* LocalTime::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000001u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::time::Time>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::proto::time::Time* LocalTime::mutable_time() {
  ::proto::time::Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.LocalTime.time)
  return _msg;
}
inline void LocalTime::set_allocated_time(::proto::time::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.LocalTime.time)
}

// -------------------------------------------------------------------

// FilteredState

// optional .proto.time.Time time = 7;
inline bool FilteredState::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool FilteredState::has_time() const {
  return _internal_has_time();
}
inline const ::proto::time::Time& FilteredState::_internal_time() const {
  const ::proto::time::Time* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::time::Time&>(
      ::proto::time::_Time_default_instance_);
}
inline const ::proto::time::Time& FilteredState::time() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.time)
  return _internal_time();
}
inline void FilteredState::unsafe_arena_set_allocated_time(
    ::proto::time::Time* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_info.FilteredState.time)
}
inline ::proto::time::Time* FilteredState::release_time() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::time::Time* FilteredState::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:proto.nav_info.FilteredState.time)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::proto::time::Time* FilteredState::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000001u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::time::Time>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::proto::time::Time* FilteredState::mutable_time() {
  ::proto::time::Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:proto.nav_info.FilteredState.time)
  return _msg;
}
inline void FilteredState::set_allocated_time(::proto::time::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_info.FilteredState.time)
}

// optional bool filter_enabled = 8;
inline bool FilteredState::_internal_has_filter_enabled() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FilteredState::has_filter_enabled() const {
  return _internal_has_filter_enabled();
}
inline void FilteredState::clear_filter_enabled() {
  filter_enabled_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool FilteredState::_internal_filter_enabled() const {
  return filter_enabled_;
}
inline bool FilteredState::filter_enabled() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.filter_enabled)
  return _internal_filter_enabled();
}
inline void FilteredState::_internal_set_filter_enabled(bool value) {
  _has_bits_[0] |= 0x00000080u;
  filter_enabled_ = value;
}
inline void FilteredState::set_filter_enabled(bool value) {
  _internal_set_filter_enabled(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.filter_enabled)
}

// optional double lat = 1;
inline bool FilteredState::_internal_has_lat() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FilteredState::has_lat() const {
  return _internal_has_lat();
}
inline void FilteredState::clear_lat() {
  lat_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double FilteredState::_internal_lat() const {
  return lat_;
}
inline double FilteredState::lat() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.lat)
  return _internal_lat();
}
inline void FilteredState::_internal_set_lat(double value) {
  _has_bits_[0] |= 0x00000002u;
  lat_ = value;
}
inline void FilteredState::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.lat)
}

// optional double lon = 2;
inline bool FilteredState::_internal_has_lon() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FilteredState::has_lon() const {
  return _internal_has_lon();
}
inline void FilteredState::clear_lon() {
  lon_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double FilteredState::_internal_lon() const {
  return lon_;
}
inline double FilteredState::lon() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.lon)
  return _internal_lon();
}
inline void FilteredState::_internal_set_lon(double value) {
  _has_bits_[0] |= 0x00000004u;
  lon_ = value;
}
inline void FilteredState::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.lon)
}

// optional bool latlon_is_filtered = 9;
inline bool FilteredState::_internal_has_latlon_is_filtered() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FilteredState::has_latlon_is_filtered() const {
  return _internal_has_latlon_is_filtered();
}
inline void FilteredState::clear_latlon_is_filtered() {
  latlon_is_filtered_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool FilteredState::_internal_latlon_is_filtered() const {
  return latlon_is_filtered_;
}
inline bool FilteredState::latlon_is_filtered() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.latlon_is_filtered)
  return _internal_latlon_is_filtered();
}
inline void FilteredState::_internal_set_latlon_is_filtered(bool value) {
  _has_bits_[0] |= 0x00000100u;
  latlon_is_filtered_ = value;
}
inline void FilteredState::set_latlon_is_filtered(bool value) {
  _internal_set_latlon_is_filtered(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.latlon_is_filtered)
}

// optional double heading = 4;
inline bool FilteredState::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FilteredState::has_heading() const {
  return _internal_has_heading();
}
inline void FilteredState::clear_heading() {
  heading_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double FilteredState::_internal_heading() const {
  return heading_;
}
inline double FilteredState::heading() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.heading)
  return _internal_heading();
}
inline void FilteredState::_internal_set_heading(double value) {
  _has_bits_[0] |= 0x00000010u;
  heading_ = value;
}
inline void FilteredState::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.heading)
}

// optional bool heading_is_filtered = 10;
inline bool FilteredState::_internal_has_heading_is_filtered() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool FilteredState::has_heading_is_filtered() const {
  return _internal_has_heading_is_filtered();
}
inline void FilteredState::clear_heading_is_filtered() {
  heading_is_filtered_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool FilteredState::_internal_heading_is_filtered() const {
  return heading_is_filtered_;
}
inline bool FilteredState::heading_is_filtered() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.heading_is_filtered)
  return _internal_heading_is_filtered();
}
inline void FilteredState::_internal_set_heading_is_filtered(bool value) {
  _has_bits_[0] |= 0x00000200u;
  heading_is_filtered_ = value;
}
inline void FilteredState::set_heading_is_filtered(bool value) {
  _internal_set_heading_is_filtered(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.heading_is_filtered)
}

// optional double speed = 3;
inline bool FilteredState::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FilteredState::has_speed() const {
  return _internal_has_speed();
}
inline void FilteredState::clear_speed() {
  speed_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double FilteredState::_internal_speed() const {
  return speed_;
}
inline double FilteredState::speed() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.speed)
  return _internal_speed();
}
inline void FilteredState::_internal_set_speed(double value) {
  _has_bits_[0] |= 0x00000008u;
  speed_ = value;
}
inline void FilteredState::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.speed)
}

// optional double course = 5;
inline bool FilteredState::_internal_has_course() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FilteredState::has_course() const {
  return _internal_has_course();
}
inline void FilteredState::clear_course() {
  course_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double FilteredState::_internal_course() const {
  return course_;
}
inline double FilteredState::course() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.course)
  return _internal_course();
}
inline void FilteredState::_internal_set_course(double value) {
  _has_bits_[0] |= 0x00000020u;
  course_ = value;
}
inline void FilteredState::set_course(double value) {
  _internal_set_course(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.course)
}

// optional double rot = 6;
inline bool FilteredState::_internal_has_rot() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FilteredState::has_rot() const {
  return _internal_has_rot();
}
inline void FilteredState::clear_rot() {
  rot_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double FilteredState::_internal_rot() const {
  return rot_;
}
inline double FilteredState::rot() const {
  // @@protoc_insertion_point(field_get:proto.nav_info.FilteredState.rot)
  return _internal_rot();
}
inline void FilteredState::_internal_set_rot(double value) {
  _has_bits_[0] |= 0x00000040u;
  rot_ = value;
}
inline void FilteredState::set_rot(double value) {
  _internal_set_rot(value);
  // @@protoc_insertion_point(field_set:proto.nav_info.FilteredState.rot)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nav_info
}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::nav_info::Heading_Type> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_nav_5finfo_2eproto
