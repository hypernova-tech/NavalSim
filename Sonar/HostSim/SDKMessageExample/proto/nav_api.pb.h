// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nav_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_nav_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_nav_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "array.pb.h"
#include "grid_description.pb.h"
#include "nav_info.pb.h"
#include "time.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_nav_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_nav_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace proto {
namespace nav_api {
class Bin;
struct BinDefaultTypeInternal;
extern BinDefaultTypeInternal _Bin_default_instance_;
class GetProcessorSettingsRequest;
struct GetProcessorSettingsRequestDefaultTypeInternal;
extern GetProcessorSettingsRequestDefaultTypeInternal _GetProcessorSettingsRequest_default_instance_;
class GetProcessorSettingsResponse;
struct GetProcessorSettingsResponseDefaultTypeInternal;
extern GetProcessorSettingsResponseDefaultTypeInternal _GetProcessorSettingsResponse_default_instance_;
class GetVesselInfoRequest;
struct GetVesselInfoRequestDefaultTypeInternal;
extern GetVesselInfoRequestDefaultTypeInternal _GetVesselInfoRequest_default_instance_;
class GetVesselInfoResponse;
struct GetVesselInfoResponseDefaultTypeInternal;
extern GetVesselInfoResponseDefaultTypeInternal _GetVesselInfoResponse_default_instance_;
class Group;
struct GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class HydrophoneData;
struct HydrophoneDataDefaultTypeInternal;
extern HydrophoneDataDefaultTypeInternal _HydrophoneData_default_instance_;
class ProcessorSettings;
struct ProcessorSettingsDefaultTypeInternal;
extern ProcessorSettingsDefaultTypeInternal _ProcessorSettings_default_instance_;
class RequestResult;
struct RequestResultDefaultTypeInternal;
extern RequestResultDefaultTypeInternal _RequestResult_default_instance_;
class SetBottomDetectionRequest;
struct SetBottomDetectionRequestDefaultTypeInternal;
extern SetBottomDetectionRequestDefaultTypeInternal _SetBottomDetectionRequest_default_instance_;
class SetBottomDetectionResponse;
struct SetBottomDetectionResponseDefaultTypeInternal;
extern SetBottomDetectionResponseDefaultTypeInternal _SetBottomDetectionResponse_default_instance_;
class SetDraftRequest;
struct SetDraftRequestDefaultTypeInternal;
extern SetDraftRequestDefaultTypeInternal _SetDraftRequest_default_instance_;
class SetDraftResponse;
struct SetDraftResponseDefaultTypeInternal;
extern SetDraftResponseDefaultTypeInternal _SetDraftResponse_default_instance_;
class SetFieldOfViewRequest;
struct SetFieldOfViewRequestDefaultTypeInternal;
extern SetFieldOfViewRequestDefaultTypeInternal _SetFieldOfViewRequest_default_instance_;
class SetFieldOfViewResponse;
struct SetFieldOfViewResponseDefaultTypeInternal;
extern SetFieldOfViewResponseDefaultTypeInternal _SetFieldOfViewResponse_default_instance_;
class SetInWaterSquelchRequest;
struct SetInWaterSquelchRequestDefaultTypeInternal;
extern SetInWaterSquelchRequestDefaultTypeInternal _SetInWaterSquelchRequest_default_instance_;
class SetInWaterSquelchResponse;
struct SetInWaterSquelchResponseDefaultTypeInternal;
extern SetInWaterSquelchResponseDefaultTypeInternal _SetInWaterSquelchResponse_default_instance_;
class SetKeelOffsetRequest;
struct SetKeelOffsetRequestDefaultTypeInternal;
extern SetKeelOffsetRequestDefaultTypeInternal _SetKeelOffsetRequest_default_instance_;
class SetKeelOffsetResponse;
struct SetKeelOffsetResponseDefaultTypeInternal;
extern SetKeelOffsetResponseDefaultTypeInternal _SetKeelOffsetResponse_default_instance_;
class SetSquelchlessInWaterDetectorRequest;
struct SetSquelchlessInWaterDetectorRequestDefaultTypeInternal;
extern SetSquelchlessInWaterDetectorRequestDefaultTypeInternal _SetSquelchlessInWaterDetectorRequest_default_instance_;
class SetSquelchlessInWaterDetectorResponse;
struct SetSquelchlessInWaterDetectorResponseDefaultTypeInternal;
extern SetSquelchlessInWaterDetectorResponseDefaultTypeInternal _SetSquelchlessInWaterDetectorResponse_default_instance_;
class TargetData;
struct TargetDataDefaultTypeInternal;
extern TargetDataDefaultTypeInternal _TargetData_default_instance_;
class VesselInfo;
struct VesselInfoDefaultTypeInternal;
extern VesselInfoDefaultTypeInternal _VesselInfo_default_instance_;
}  // namespace nav_api
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::nav_api::Bin* Arena::CreateMaybeMessage<::proto::nav_api::Bin>(Arena*);
template<> ::proto::nav_api::GetProcessorSettingsRequest* Arena::CreateMaybeMessage<::proto::nav_api::GetProcessorSettingsRequest>(Arena*);
template<> ::proto::nav_api::GetProcessorSettingsResponse* Arena::CreateMaybeMessage<::proto::nav_api::GetProcessorSettingsResponse>(Arena*);
template<> ::proto::nav_api::GetVesselInfoRequest* Arena::CreateMaybeMessage<::proto::nav_api::GetVesselInfoRequest>(Arena*);
template<> ::proto::nav_api::GetVesselInfoResponse* Arena::CreateMaybeMessage<::proto::nav_api::GetVesselInfoResponse>(Arena*);
template<> ::proto::nav_api::Group* Arena::CreateMaybeMessage<::proto::nav_api::Group>(Arena*);
template<> ::proto::nav_api::HydrophoneData* Arena::CreateMaybeMessage<::proto::nav_api::HydrophoneData>(Arena*);
template<> ::proto::nav_api::ProcessorSettings* Arena::CreateMaybeMessage<::proto::nav_api::ProcessorSettings>(Arena*);
template<> ::proto::nav_api::RequestResult* Arena::CreateMaybeMessage<::proto::nav_api::RequestResult>(Arena*);
template<> ::proto::nav_api::SetBottomDetectionRequest* Arena::CreateMaybeMessage<::proto::nav_api::SetBottomDetectionRequest>(Arena*);
template<> ::proto::nav_api::SetBottomDetectionResponse* Arena::CreateMaybeMessage<::proto::nav_api::SetBottomDetectionResponse>(Arena*);
template<> ::proto::nav_api::SetDraftRequest* Arena::CreateMaybeMessage<::proto::nav_api::SetDraftRequest>(Arena*);
template<> ::proto::nav_api::SetDraftResponse* Arena::CreateMaybeMessage<::proto::nav_api::SetDraftResponse>(Arena*);
template<> ::proto::nav_api::SetFieldOfViewRequest* Arena::CreateMaybeMessage<::proto::nav_api::SetFieldOfViewRequest>(Arena*);
template<> ::proto::nav_api::SetFieldOfViewResponse* Arena::CreateMaybeMessage<::proto::nav_api::SetFieldOfViewResponse>(Arena*);
template<> ::proto::nav_api::SetInWaterSquelchRequest* Arena::CreateMaybeMessage<::proto::nav_api::SetInWaterSquelchRequest>(Arena*);
template<> ::proto::nav_api::SetInWaterSquelchResponse* Arena::CreateMaybeMessage<::proto::nav_api::SetInWaterSquelchResponse>(Arena*);
template<> ::proto::nav_api::SetKeelOffsetRequest* Arena::CreateMaybeMessage<::proto::nav_api::SetKeelOffsetRequest>(Arena*);
template<> ::proto::nav_api::SetKeelOffsetResponse* Arena::CreateMaybeMessage<::proto::nav_api::SetKeelOffsetResponse>(Arena*);
template<> ::proto::nav_api::SetSquelchlessInWaterDetectorRequest* Arena::CreateMaybeMessage<::proto::nav_api::SetSquelchlessInWaterDetectorRequest>(Arena*);
template<> ::proto::nav_api::SetSquelchlessInWaterDetectorResponse* Arena::CreateMaybeMessage<::proto::nav_api::SetSquelchlessInWaterDetectorResponse>(Arena*);
template<> ::proto::nav_api::TargetData* Arena::CreateMaybeMessage<::proto::nav_api::TargetData>(Arena*);
template<> ::proto::nav_api::VesselInfo* Arena::CreateMaybeMessage<::proto::nav_api::VesselInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {
namespace nav_api {

enum RequestResult_ResultCode : int {
  RequestResult_ResultCode_kSuccess = 0,
  RequestResult_ResultCode_kUnknownError = 1,
  RequestResult_ResultCode_kOperationUnavailable = 2,
  RequestResult_ResultCode_kParameterOutOfRange = 3,
  RequestResult_ResultCode_kParameterMissing = 4,
  RequestResult_ResultCode_kInvalidRequest = 5
};
bool RequestResult_ResultCode_IsValid(int value);
constexpr RequestResult_ResultCode RequestResult_ResultCode_ResultCode_MIN = RequestResult_ResultCode_kSuccess;
constexpr RequestResult_ResultCode RequestResult_ResultCode_ResultCode_MAX = RequestResult_ResultCode_kInvalidRequest;
constexpr int RequestResult_ResultCode_ResultCode_ARRAYSIZE = RequestResult_ResultCode_ResultCode_MAX + 1;

const std::string& RequestResult_ResultCode_Name(RequestResult_ResultCode value);
template<typename T>
inline const std::string& RequestResult_ResultCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestResult_ResultCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestResult_ResultCode_Name.");
  return RequestResult_ResultCode_Name(static_cast<RequestResult_ResultCode>(enum_t_value));
}
bool RequestResult_ResultCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestResult_ResultCode* value);
enum ProcessorSettings_SystemType : int {
  ProcessorSettings_SystemType_kFS3DT = 0,
  ProcessorSettings_SystemType_kFS500 = 1,
  ProcessorSettings_SystemType_kFS1000 = 2,
  ProcessorSettings_SystemType_kFS350 = 3
};
bool ProcessorSettings_SystemType_IsValid(int value);
constexpr ProcessorSettings_SystemType ProcessorSettings_SystemType_SystemType_MIN = ProcessorSettings_SystemType_kFS3DT;
constexpr ProcessorSettings_SystemType ProcessorSettings_SystemType_SystemType_MAX = ProcessorSettings_SystemType_kFS350;
constexpr int ProcessorSettings_SystemType_SystemType_ARRAYSIZE = ProcessorSettings_SystemType_SystemType_MAX + 1;

const std::string& ProcessorSettings_SystemType_Name(ProcessorSettings_SystemType value);
template<typename T>
inline const std::string& ProcessorSettings_SystemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessorSettings_SystemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessorSettings_SystemType_Name.");
  return ProcessorSettings_SystemType_Name(static_cast<ProcessorSettings_SystemType>(enum_t_value));
}
bool ProcessorSettings_SystemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessorSettings_SystemType* value);
enum FieldOfView : int {
  k90d110m = 0,
  k90d220m = 1,
  k90d330m = 2,
  k60d440m = 3,
  kAlt = 4,
  k120d100m = 5,
  k120d200m = 6,
  k90d500m = 7,
  k60d1000m = 8,
  k90d100m = 9,
  k90d200m = 10,
  k90d350m = 11
};
bool FieldOfView_IsValid(int value);
constexpr FieldOfView FieldOfView_MIN = k90d110m;
constexpr FieldOfView FieldOfView_MAX = k90d350m;
constexpr int FieldOfView_ARRAYSIZE = FieldOfView_MAX + 1;

const std::string& FieldOfView_Name(FieldOfView value);
template<typename T>
inline const std::string& FieldOfView_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FieldOfView>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FieldOfView_Name.");
  return FieldOfView_Name(static_cast<FieldOfView>(enum_t_value));
}
bool FieldOfView_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FieldOfView* value);
// ===================================================================

class RequestResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.RequestResult) */ {
 public:
  inline RequestResult() : RequestResult(nullptr) {}
  ~RequestResult() override;
  explicit constexpr RequestResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestResult(const RequestResult& from);
  RequestResult(RequestResult&& from) noexcept
    : RequestResult() {
    *this = ::std::move(from);
  }

  inline RequestResult& operator=(const RequestResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestResult& operator=(RequestResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RequestResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestResult* internal_default_instance() {
    return reinterpret_cast<const RequestResult*>(
               &_RequestResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RequestResult& a, RequestResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RequestResult& from);
  void MergeFrom(const RequestResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.RequestResult";
  }
  protected:
  explicit RequestResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RequestResult_ResultCode ResultCode;
  static constexpr ResultCode kSuccess =
    RequestResult_ResultCode_kSuccess;
  static constexpr ResultCode kUnknownError =
    RequestResult_ResultCode_kUnknownError;
  static constexpr ResultCode kOperationUnavailable =
    RequestResult_ResultCode_kOperationUnavailable;
  static constexpr ResultCode kParameterOutOfRange =
    RequestResult_ResultCode_kParameterOutOfRange;
  static constexpr ResultCode kParameterMissing =
    RequestResult_ResultCode_kParameterMissing;
  static constexpr ResultCode kInvalidRequest =
    RequestResult_ResultCode_kInvalidRequest;
  static inline bool ResultCode_IsValid(int value) {
    return RequestResult_ResultCode_IsValid(value);
  }
  static constexpr ResultCode ResultCode_MIN =
    RequestResult_ResultCode_ResultCode_MIN;
  static constexpr ResultCode ResultCode_MAX =
    RequestResult_ResultCode_ResultCode_MAX;
  static constexpr int ResultCode_ARRAYSIZE =
    RequestResult_ResultCode_ResultCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResultCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResultCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResultCode_Name.");
    return RequestResult_ResultCode_Name(enum_t_value);
  }
  static inline bool ResultCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResultCode* value) {
    return RequestResult_ResultCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultDetailFieldNumber = 3,
    kTimeFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // optional string result_detail = 3;
  bool has_result_detail() const;
  private:
  bool _internal_has_result_detail() const;
  public:
  void clear_result_detail();
  const std::string& result_detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_detail();
  PROTOBUF_NODISCARD std::string* release_result_detail();
  void set_allocated_result_detail(std::string* result_detail);
  private:
  const std::string& _internal_result_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_detail(const std::string& value);
  std::string* _internal_mutable_result_detail();
  public:

  // optional .proto.time.Time time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::proto::time::Time& time() const;
  PROTOBUF_NODISCARD ::proto::time::Time* release_time();
  ::proto::time::Time* mutable_time();
  void set_allocated_time(::proto::time::Time* time);
  private:
  const ::proto::time::Time& _internal_time() const;
  ::proto::time::Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::proto::time::Time* time);
  ::proto::time::Time* unsafe_arena_release_time();

  // optional .proto.nav_api.RequestResult.ResultCode code = 2;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  ::proto::nav_api::RequestResult_ResultCode code() const;
  void set_code(::proto::nav_api::RequestResult_ResultCode value);
  private:
  ::proto::nav_api::RequestResult_ResultCode _internal_code() const;
  void _internal_set_code(::proto::nav_api::RequestResult_ResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.RequestResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_detail_;
  ::proto::time::Time* time_;
  int code_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class HydrophoneData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.HydrophoneData) */ {
 public:
  inline HydrophoneData() : HydrophoneData(nullptr) {}
  ~HydrophoneData() override;
  explicit constexpr HydrophoneData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HydrophoneData(const HydrophoneData& from);
  HydrophoneData(HydrophoneData&& from) noexcept
    : HydrophoneData() {
    *this = ::std::move(from);
  }

  inline HydrophoneData& operator=(const HydrophoneData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HydrophoneData& operator=(HydrophoneData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HydrophoneData& default_instance() {
    return *internal_default_instance();
  }
  static inline const HydrophoneData* internal_default_instance() {
    return reinterpret_cast<const HydrophoneData*>(
               &_HydrophoneData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HydrophoneData& a, HydrophoneData& b) {
    a.Swap(&b);
  }
  inline void Swap(HydrophoneData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HydrophoneData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HydrophoneData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HydrophoneData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HydrophoneData& from);
  void MergeFrom(const HydrophoneData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HydrophoneData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.HydrophoneData";
  }
  protected:
  explicit HydrophoneData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialFieldNumber = 5,
    kTransmitIdFieldNumber = 6,
    kTimeFieldNumber = 1,
    kRawTimeseriesFieldNumber = 2,
    kNumHorPhonesFieldNumber = 3,
    kNumVerPhonesFieldNumber = 4,
  };
  // optional string serial = 5;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // optional string transmit_id = 6;
  bool has_transmit_id() const;
  private:
  bool _internal_has_transmit_id() const;
  public:
  void clear_transmit_id();
  const std::string& transmit_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transmit_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transmit_id();
  PROTOBUF_NODISCARD std::string* release_transmit_id();
  void set_allocated_transmit_id(std::string* transmit_id);
  private:
  const std::string& _internal_transmit_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmit_id(const std::string& value);
  std::string* _internal_mutable_transmit_id();
  public:

  // optional .proto.time.Time time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::proto::time::Time& time() const;
  PROTOBUF_NODISCARD ::proto::time::Time* release_time();
  ::proto::time::Time* mutable_time();
  void set_allocated_time(::proto::time::Time* time);
  private:
  const ::proto::time::Time& _internal_time() const;
  ::proto::time::Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::proto::time::Time* time);
  ::proto::time::Time* unsafe_arena_release_time();

  // optional .proto.array.ArrayData raw_timeseries = 2;
  bool has_raw_timeseries() const;
  private:
  bool _internal_has_raw_timeseries() const;
  public:
  void clear_raw_timeseries();
  const ::proto::array::ArrayData& raw_timeseries() const;
  PROTOBUF_NODISCARD ::proto::array::ArrayData* release_raw_timeseries();
  ::proto::array::ArrayData* mutable_raw_timeseries();
  void set_allocated_raw_timeseries(::proto::array::ArrayData* raw_timeseries);
  private:
  const ::proto::array::ArrayData& _internal_raw_timeseries() const;
  ::proto::array::ArrayData* _internal_mutable_raw_timeseries();
  public:
  void unsafe_arena_set_allocated_raw_timeseries(
      ::proto::array::ArrayData* raw_timeseries);
  ::proto::array::ArrayData* unsafe_arena_release_raw_timeseries();

  // optional int32 num_hor_phones = 3;
  bool has_num_hor_phones() const;
  private:
  bool _internal_has_num_hor_phones() const;
  public:
  void clear_num_hor_phones();
  int32_t num_hor_phones() const;
  void set_num_hor_phones(int32_t value);
  private:
  int32_t _internal_num_hor_phones() const;
  void _internal_set_num_hor_phones(int32_t value);
  public:

  // optional int32 num_ver_phones = 4;
  bool has_num_ver_phones() const;
  private:
  bool _internal_has_num_ver_phones() const;
  public:
  void clear_num_ver_phones();
  int32_t num_ver_phones() const;
  void set_num_ver_phones(int32_t value);
  private:
  int32_t _internal_num_ver_phones() const;
  void _internal_set_num_ver_phones(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.HydrophoneData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmit_id_;
  ::proto::time::Time* time_;
  ::proto::array::ArrayData* raw_timeseries_;
  int32_t num_hor_phones_;
  int32_t num_ver_phones_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class TargetData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.TargetData) */ {
 public:
  inline TargetData() : TargetData(nullptr) {}
  ~TargetData() override;
  explicit constexpr TargetData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetData(const TargetData& from);
  TargetData(TargetData&& from) noexcept
    : TargetData() {
    *this = ::std::move(from);
  }

  inline TargetData& operator=(const TargetData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetData& operator=(TargetData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TargetData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetData* internal_default_instance() {
    return reinterpret_cast<const TargetData*>(
               &_TargetData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TargetData& a, TargetData& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TargetData& from);
  void MergeFrom(const TargetData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TargetData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.TargetData";
  }
  protected:
  explicit TargetData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBottomFieldNumber = 6,
    kGroupsFieldNumber = 7,
    kSerialFieldNumber = 2,
    kTimeFieldNumber = 1,
    kHeadingFieldNumber = 4,
    kPositionFieldNumber = 5,
    kGridDescriptionFieldNumber = 8,
    kMaxDepthFieldNumber = 9,
    kMaxRangeIndexFieldNumber = 10,
  };
  // repeated .proto.nav_api.Bin bottom = 6;
  int bottom_size() const;
  private:
  int _internal_bottom_size() const;
  public:
  void clear_bottom();
  ::proto::nav_api::Bin* mutable_bottom(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin >*
      mutable_bottom();
  private:
  const ::proto::nav_api::Bin& _internal_bottom(int index) const;
  ::proto::nav_api::Bin* _internal_add_bottom();
  public:
  const ::proto::nav_api::Bin& bottom(int index) const;
  ::proto::nav_api::Bin* add_bottom();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin >&
      bottom() const;

  // repeated .proto.nav_api.Group groups = 7;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::proto::nav_api::Group* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Group >*
      mutable_groups();
  private:
  const ::proto::nav_api::Group& _internal_groups(int index) const;
  ::proto::nav_api::Group* _internal_add_groups();
  public:
  const ::proto::nav_api::Group& groups(int index) const;
  ::proto::nav_api::Group* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Group >&
      groups() const;

  // optional string serial = 2;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // optional .proto.time.Time time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::proto::time::Time& time() const;
  PROTOBUF_NODISCARD ::proto::time::Time* release_time();
  ::proto::time::Time* mutable_time();
  void set_allocated_time(::proto::time::Time* time);
  private:
  const ::proto::time::Time& _internal_time() const;
  ::proto::time::Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::proto::time::Time* time);
  ::proto::time::Time* unsafe_arena_release_time();

  // optional .proto.nav_info.Heading heading = 4;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  const ::proto::nav_info::Heading& heading() const;
  PROTOBUF_NODISCARD ::proto::nav_info::Heading* release_heading();
  ::proto::nav_info::Heading* mutable_heading();
  void set_allocated_heading(::proto::nav_info::Heading* heading);
  private:
  const ::proto::nav_info::Heading& _internal_heading() const;
  ::proto::nav_info::Heading* _internal_mutable_heading();
  public:
  void unsafe_arena_set_allocated_heading(
      ::proto::nav_info::Heading* heading);
  ::proto::nav_info::Heading* unsafe_arena_release_heading();

  // optional .proto.nav_info.Position position = 5;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::proto::nav_info::Position& position() const;
  PROTOBUF_NODISCARD ::proto::nav_info::Position* release_position();
  ::proto::nav_info::Position* mutable_position();
  void set_allocated_position(::proto::nav_info::Position* position);
  private:
  const ::proto::nav_info::Position& _internal_position() const;
  ::proto::nav_info::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::proto::nav_info::Position* position);
  ::proto::nav_info::Position* unsafe_arena_release_position();

  // optional .proto.grid_description.GridDescription grid_description = 8;
  bool has_grid_description() const;
  private:
  bool _internal_has_grid_description() const;
  public:
  void clear_grid_description();
  const ::proto::grid_description::GridDescription& grid_description() const;
  PROTOBUF_NODISCARD ::proto::grid_description::GridDescription* release_grid_description();
  ::proto::grid_description::GridDescription* mutable_grid_description();
  void set_allocated_grid_description(::proto::grid_description::GridDescription* grid_description);
  private:
  const ::proto::grid_description::GridDescription& _internal_grid_description() const;
  ::proto::grid_description::GridDescription* _internal_mutable_grid_description();
  public:
  void unsafe_arena_set_allocated_grid_description(
      ::proto::grid_description::GridDescription* grid_description);
  ::proto::grid_description::GridDescription* unsafe_arena_release_grid_description();

  // optional double max_depth = 9;
  bool has_max_depth() const;
  private:
  bool _internal_has_max_depth() const;
  public:
  void clear_max_depth();
  double max_depth() const;
  void set_max_depth(double value);
  private:
  double _internal_max_depth() const;
  void _internal_set_max_depth(double value);
  public:

  // optional int32 max_range_index = 10;
  bool has_max_range_index() const;
  private:
  bool _internal_has_max_range_index() const;
  public:
  void clear_max_range_index();
  int32_t max_range_index() const;
  void set_max_range_index(int32_t value);
  private:
  int32_t _internal_max_range_index() const;
  void _internal_set_max_range_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.TargetData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin > bottom_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Group > groups_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::proto::time::Time* time_;
  ::proto::nav_info::Heading* heading_;
  ::proto::nav_info::Position* position_;
  ::proto::grid_description::GridDescription* grid_description_;
  double max_depth_;
  int32_t max_range_index_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class Bin final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.Bin) */ {
 public:
  inline Bin() : Bin(nullptr) {}
  ~Bin() override;
  explicit constexpr Bin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bin(const Bin& from);
  Bin(Bin&& from) noexcept
    : Bin() {
    *this = ::std::move(from);
  }

  inline Bin& operator=(const Bin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bin& operator=(Bin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Bin& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bin* internal_default_instance() {
    return reinterpret_cast<const Bin*>(
               &_Bin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Bin& a, Bin& b) {
    a.Swap(&b);
  }
  inline void Swap(Bin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Bin& from);
  void MergeFrom(const Bin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.Bin";
  }
  protected:
  explicit Bin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHorIndexFieldNumber = 1,
    kVerIndexFieldNumber = 2,
    kRangeIndexFieldNumber = 3,
    kCrossRangeFieldNumber = 4,
    kDownRangeFieldNumber = 5,
    kDepthFieldNumber = 6,
    kStrengthFieldNumber = 7,
    kConfidenceFieldNumber = 8,
  };
  // optional int32 hor_index = 1;
  bool has_hor_index() const;
  private:
  bool _internal_has_hor_index() const;
  public:
  void clear_hor_index();
  int32_t hor_index() const;
  void set_hor_index(int32_t value);
  private:
  int32_t _internal_hor_index() const;
  void _internal_set_hor_index(int32_t value);
  public:

  // optional int32 ver_index = 2;
  bool has_ver_index() const;
  private:
  bool _internal_has_ver_index() const;
  public:
  void clear_ver_index();
  int32_t ver_index() const;
  void set_ver_index(int32_t value);
  private:
  int32_t _internal_ver_index() const;
  void _internal_set_ver_index(int32_t value);
  public:

  // optional int32 range_index = 3;
  bool has_range_index() const;
  private:
  bool _internal_has_range_index() const;
  public:
  void clear_range_index();
  int32_t range_index() const;
  void set_range_index(int32_t value);
  private:
  int32_t _internal_range_index() const;
  void _internal_set_range_index(int32_t value);
  public:

  // optional float cross_range = 4;
  bool has_cross_range() const;
  private:
  bool _internal_has_cross_range() const;
  public:
  void clear_cross_range();
  float cross_range() const;
  void set_cross_range(float value);
  private:
  float _internal_cross_range() const;
  void _internal_set_cross_range(float value);
  public:

  // optional float down_range = 5;
  bool has_down_range() const;
  private:
  bool _internal_has_down_range() const;
  public:
  void clear_down_range();
  float down_range() const;
  void set_down_range(float value);
  private:
  float _internal_down_range() const;
  void _internal_set_down_range(float value);
  public:

  // optional float depth = 6;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  float depth() const;
  void set_depth(float value);
  private:
  float _internal_depth() const;
  void _internal_set_depth(float value);
  public:

  // optional float strength = 7;
  bool has_strength() const;
  private:
  bool _internal_has_strength() const;
  public:
  void clear_strength();
  float strength() const;
  void set_strength(float value);
  private:
  float _internal_strength() const;
  void _internal_set_strength(float value);
  public:

  // optional float confidence = 8;
  bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.Bin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t hor_index_;
  int32_t ver_index_;
  int32_t range_index_;
  float cross_range_;
  float down_range_;
  float depth_;
  float strength_;
  float confidence_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class Group final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.Group) */ {
 public:
  inline Group() : Group(nullptr) {}
  ~Group() override;
  explicit constexpr Group(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Group(const Group& from);
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  inline Group& operator=(Group&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Group& default_instance() {
    return *internal_default_instance();
  }
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }
  inline void Swap(Group* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Group* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Group* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Group* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.Group";
  }
  protected:
  explicit Group(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinsFieldNumber = 1,
  };
  // repeated .proto.nav_api.Bin bins = 1;
  int bins_size() const;
  private:
  int _internal_bins_size() const;
  public:
  void clear_bins();
  ::proto::nav_api::Bin* mutable_bins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin >*
      mutable_bins();
  private:
  const ::proto::nav_api::Bin& _internal_bins(int index) const;
  ::proto::nav_api::Bin* _internal_add_bins();
  public:
  const ::proto::nav_api::Bin& bins(int index) const;
  ::proto::nav_api::Bin* add_bins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin >&
      bins() const;

  // @@protoc_insertion_point(class_scope:proto.nav_api.Group)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin > bins_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ProcessorSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.ProcessorSettings) */ {
 public:
  inline ProcessorSettings() : ProcessorSettings(nullptr) {}
  ~ProcessorSettings() override;
  explicit constexpr ProcessorSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessorSettings(const ProcessorSettings& from);
  ProcessorSettings(ProcessorSettings&& from) noexcept
    : ProcessorSettings() {
    *this = ::std::move(from);
  }

  inline ProcessorSettings& operator=(const ProcessorSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorSettings& operator=(ProcessorSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProcessorSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessorSettings* internal_default_instance() {
    return reinterpret_cast<const ProcessorSettings*>(
               &_ProcessorSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProcessorSettings& a, ProcessorSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessorSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessorSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProcessorSettings& from);
  void MergeFrom(const ProcessorSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessorSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.ProcessorSettings";
  }
  protected:
  explicit ProcessorSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ProcessorSettings_SystemType SystemType;
  static constexpr SystemType kFS3DT =
    ProcessorSettings_SystemType_kFS3DT;
  static constexpr SystemType kFS500 =
    ProcessorSettings_SystemType_kFS500;
  static constexpr SystemType kFS1000 =
    ProcessorSettings_SystemType_kFS1000;
  static constexpr SystemType kFS350 =
    ProcessorSettings_SystemType_kFS350;
  static inline bool SystemType_IsValid(int value) {
    return ProcessorSettings_SystemType_IsValid(value);
  }
  static constexpr SystemType SystemType_MIN =
    ProcessorSettings_SystemType_SystemType_MIN;
  static constexpr SystemType SystemType_MAX =
    ProcessorSettings_SystemType_SystemType_MAX;
  static constexpr int SystemType_ARRAYSIZE =
    ProcessorSettings_SystemType_SystemType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SystemType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SystemType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SystemType_Name.");
    return ProcessorSettings_SystemType_Name(enum_t_value);
  }
  static inline bool SystemType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SystemType* value) {
    return ProcessorSettings_SystemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kMinInwaterSquelchFieldNumber = 2,
    kMaxInwaterSquelchFieldNumber = 3,
    kInwaterSquelchFieldNumber = 4,
    kSquelchlessInwaterDetectorFieldNumber = 5,
    kDetectBottomFieldNumber = 6,
    kSystemTypeFieldNumber = 7,
    kFovFieldNumber = 8,
  };
  // optional .proto.time.Time time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::proto::time::Time& time() const;
  PROTOBUF_NODISCARD ::proto::time::Time* release_time();
  ::proto::time::Time* mutable_time();
  void set_allocated_time(::proto::time::Time* time);
  private:
  const ::proto::time::Time& _internal_time() const;
  ::proto::time::Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::proto::time::Time* time);
  ::proto::time::Time* unsafe_arena_release_time();

  // optional float min_inwater_squelch = 2;
  bool has_min_inwater_squelch() const;
  private:
  bool _internal_has_min_inwater_squelch() const;
  public:
  void clear_min_inwater_squelch();
  float min_inwater_squelch() const;
  void set_min_inwater_squelch(float value);
  private:
  float _internal_min_inwater_squelch() const;
  void _internal_set_min_inwater_squelch(float value);
  public:

  // optional float max_inwater_squelch = 3;
  bool has_max_inwater_squelch() const;
  private:
  bool _internal_has_max_inwater_squelch() const;
  public:
  void clear_max_inwater_squelch();
  float max_inwater_squelch() const;
  void set_max_inwater_squelch(float value);
  private:
  float _internal_max_inwater_squelch() const;
  void _internal_set_max_inwater_squelch(float value);
  public:

  // optional float inwater_squelch = 4;
  bool has_inwater_squelch() const;
  private:
  bool _internal_has_inwater_squelch() const;
  public:
  void clear_inwater_squelch();
  float inwater_squelch() const;
  void set_inwater_squelch(float value);
  private:
  float _internal_inwater_squelch() const;
  void _internal_set_inwater_squelch(float value);
  public:

  // optional bool squelchless_inwater_detector = 5;
  bool has_squelchless_inwater_detector() const;
  private:
  bool _internal_has_squelchless_inwater_detector() const;
  public:
  void clear_squelchless_inwater_detector();
  bool squelchless_inwater_detector() const;
  void set_squelchless_inwater_detector(bool value);
  private:
  bool _internal_squelchless_inwater_detector() const;
  void _internal_set_squelchless_inwater_detector(bool value);
  public:

  // optional bool detect_bottom = 6;
  bool has_detect_bottom() const;
  private:
  bool _internal_has_detect_bottom() const;
  public:
  void clear_detect_bottom();
  bool detect_bottom() const;
  void set_detect_bottom(bool value);
  private:
  bool _internal_detect_bottom() const;
  void _internal_set_detect_bottom(bool value);
  public:

  // optional .proto.nav_api.ProcessorSettings.SystemType system_type = 7 [default = kFS3DT];
  bool has_system_type() const;
  private:
  bool _internal_has_system_type() const;
  public:
  void clear_system_type();
  ::proto::nav_api::ProcessorSettings_SystemType system_type() const;
  void set_system_type(::proto::nav_api::ProcessorSettings_SystemType value);
  private:
  ::proto::nav_api::ProcessorSettings_SystemType _internal_system_type() const;
  void _internal_set_system_type(::proto::nav_api::ProcessorSettings_SystemType value);
  public:

  // optional .proto.nav_api.FieldOfView fov = 8 [default = k90d330m];
  bool has_fov() const;
  private:
  bool _internal_has_fov() const;
  public:
  void clear_fov();
  ::proto::nav_api::FieldOfView fov() const;
  void set_fov(::proto::nav_api::FieldOfView value);
  private:
  ::proto::nav_api::FieldOfView _internal_fov() const;
  void _internal_set_fov(::proto::nav_api::FieldOfView value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.ProcessorSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::time::Time* time_;
  float min_inwater_squelch_;
  float max_inwater_squelch_;
  float inwater_squelch_;
  bool squelchless_inwater_detector_;
  bool detect_bottom_;
  int system_type_;
  int fov_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProcessorSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.GetProcessorSettingsRequest) */ {
 public:
  inline GetProcessorSettingsRequest() : GetProcessorSettingsRequest(nullptr) {}
  ~GetProcessorSettingsRequest() override;
  explicit constexpr GetProcessorSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProcessorSettingsRequest(const GetProcessorSettingsRequest& from);
  GetProcessorSettingsRequest(GetProcessorSettingsRequest&& from) noexcept
    : GetProcessorSettingsRequest() {
    *this = ::std::move(from);
  }

  inline GetProcessorSettingsRequest& operator=(const GetProcessorSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProcessorSettingsRequest& operator=(GetProcessorSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetProcessorSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProcessorSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const GetProcessorSettingsRequest*>(
               &_GetProcessorSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetProcessorSettingsRequest& a, GetProcessorSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProcessorSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProcessorSettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProcessorSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProcessorSettingsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetProcessorSettingsRequest& from);
  void MergeFrom(const GetProcessorSettingsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetProcessorSettingsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.GetProcessorSettingsRequest";
  }
  protected:
  explicit GetProcessorSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.nav_api.GetProcessorSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProcessorSettingsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.GetProcessorSettingsResponse) */ {
 public:
  inline GetProcessorSettingsResponse() : GetProcessorSettingsResponse(nullptr) {}
  ~GetProcessorSettingsResponse() override;
  explicit constexpr GetProcessorSettingsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProcessorSettingsResponse(const GetProcessorSettingsResponse& from);
  GetProcessorSettingsResponse(GetProcessorSettingsResponse&& from) noexcept
    : GetProcessorSettingsResponse() {
    *this = ::std::move(from);
  }

  inline GetProcessorSettingsResponse& operator=(const GetProcessorSettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProcessorSettingsResponse& operator=(GetProcessorSettingsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetProcessorSettingsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProcessorSettingsResponse* internal_default_instance() {
    return reinterpret_cast<const GetProcessorSettingsResponse*>(
               &_GetProcessorSettingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetProcessorSettingsResponse& a, GetProcessorSettingsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProcessorSettingsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProcessorSettingsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProcessorSettingsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProcessorSettingsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetProcessorSettingsResponse& from);
  void MergeFrom(const GetProcessorSettingsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetProcessorSettingsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.GetProcessorSettingsResponse";
  }
  protected:
  explicit GetProcessorSettingsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kSettingsFieldNumber = 2,
  };
  // optional .proto.nav_api.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::proto::nav_api::RequestResult& result() const;
  PROTOBUF_NODISCARD ::proto::nav_api::RequestResult* release_result();
  ::proto::nav_api::RequestResult* mutable_result();
  void set_allocated_result(::proto::nav_api::RequestResult* result);
  private:
  const ::proto::nav_api::RequestResult& _internal_result() const;
  ::proto::nav_api::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::proto::nav_api::RequestResult* result);
  ::proto::nav_api::RequestResult* unsafe_arena_release_result();

  // optional .proto.nav_api.ProcessorSettings settings = 2;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::proto::nav_api::ProcessorSettings& settings() const;
  PROTOBUF_NODISCARD ::proto::nav_api::ProcessorSettings* release_settings();
  ::proto::nav_api::ProcessorSettings* mutable_settings();
  void set_allocated_settings(::proto::nav_api::ProcessorSettings* settings);
  private:
  const ::proto::nav_api::ProcessorSettings& _internal_settings() const;
  ::proto::nav_api::ProcessorSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::proto::nav_api::ProcessorSettings* settings);
  ::proto::nav_api::ProcessorSettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:proto.nav_api.GetProcessorSettingsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nav_api::RequestResult* result_;
  ::proto::nav_api::ProcessorSettings* settings_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetFieldOfViewRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetFieldOfViewRequest) */ {
 public:
  inline SetFieldOfViewRequest() : SetFieldOfViewRequest(nullptr) {}
  ~SetFieldOfViewRequest() override;
  explicit constexpr SetFieldOfViewRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFieldOfViewRequest(const SetFieldOfViewRequest& from);
  SetFieldOfViewRequest(SetFieldOfViewRequest&& from) noexcept
    : SetFieldOfViewRequest() {
    *this = ::std::move(from);
  }

  inline SetFieldOfViewRequest& operator=(const SetFieldOfViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFieldOfViewRequest& operator=(SetFieldOfViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetFieldOfViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFieldOfViewRequest* internal_default_instance() {
    return reinterpret_cast<const SetFieldOfViewRequest*>(
               &_SetFieldOfViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SetFieldOfViewRequest& a, SetFieldOfViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFieldOfViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFieldOfViewRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFieldOfViewRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFieldOfViewRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetFieldOfViewRequest& from);
  void MergeFrom(const SetFieldOfViewRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetFieldOfViewRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetFieldOfViewRequest";
  }
  protected:
  explicit SetFieldOfViewRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFovFieldNumber = 1,
  };
  // optional .proto.nav_api.FieldOfView fov = 1;
  bool has_fov() const;
  private:
  bool _internal_has_fov() const;
  public:
  void clear_fov();
  ::proto::nav_api::FieldOfView fov() const;
  void set_fov(::proto::nav_api::FieldOfView value);
  private:
  ::proto::nav_api::FieldOfView _internal_fov() const;
  void _internal_set_fov(::proto::nav_api::FieldOfView value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetFieldOfViewRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int fov_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetFieldOfViewResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetFieldOfViewResponse) */ {
 public:
  inline SetFieldOfViewResponse() : SetFieldOfViewResponse(nullptr) {}
  ~SetFieldOfViewResponse() override;
  explicit constexpr SetFieldOfViewResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFieldOfViewResponse(const SetFieldOfViewResponse& from);
  SetFieldOfViewResponse(SetFieldOfViewResponse&& from) noexcept
    : SetFieldOfViewResponse() {
    *this = ::std::move(from);
  }

  inline SetFieldOfViewResponse& operator=(const SetFieldOfViewResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFieldOfViewResponse& operator=(SetFieldOfViewResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetFieldOfViewResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFieldOfViewResponse* internal_default_instance() {
    return reinterpret_cast<const SetFieldOfViewResponse*>(
               &_SetFieldOfViewResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SetFieldOfViewResponse& a, SetFieldOfViewResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFieldOfViewResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFieldOfViewResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFieldOfViewResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFieldOfViewResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetFieldOfViewResponse& from);
  void MergeFrom(const SetFieldOfViewResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetFieldOfViewResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetFieldOfViewResponse";
  }
  protected:
  explicit SetFieldOfViewResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .proto.nav_api.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::proto::nav_api::RequestResult& result() const;
  PROTOBUF_NODISCARD ::proto::nav_api::RequestResult* release_result();
  ::proto::nav_api::RequestResult* mutable_result();
  void set_allocated_result(::proto::nav_api::RequestResult* result);
  private:
  const ::proto::nav_api::RequestResult& _internal_result() const;
  ::proto::nav_api::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::proto::nav_api::RequestResult* result);
  ::proto::nav_api::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetFieldOfViewResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nav_api::RequestResult* result_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetBottomDetectionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetBottomDetectionRequest) */ {
 public:
  inline SetBottomDetectionRequest() : SetBottomDetectionRequest(nullptr) {}
  ~SetBottomDetectionRequest() override;
  explicit constexpr SetBottomDetectionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetBottomDetectionRequest(const SetBottomDetectionRequest& from);
  SetBottomDetectionRequest(SetBottomDetectionRequest&& from) noexcept
    : SetBottomDetectionRequest() {
    *this = ::std::move(from);
  }

  inline SetBottomDetectionRequest& operator=(const SetBottomDetectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetBottomDetectionRequest& operator=(SetBottomDetectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetBottomDetectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetBottomDetectionRequest* internal_default_instance() {
    return reinterpret_cast<const SetBottomDetectionRequest*>(
               &_SetBottomDetectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetBottomDetectionRequest& a, SetBottomDetectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetBottomDetectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetBottomDetectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetBottomDetectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetBottomDetectionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetBottomDetectionRequest& from);
  void MergeFrom(const SetBottomDetectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetBottomDetectionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetBottomDetectionRequest";
  }
  protected:
  explicit SetBottomDetectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableBottomDetectionFieldNumber = 1,
  };
  // optional bool enable_bottom_detection = 1;
  bool has_enable_bottom_detection() const;
  private:
  bool _internal_has_enable_bottom_detection() const;
  public:
  void clear_enable_bottom_detection();
  bool enable_bottom_detection() const;
  void set_enable_bottom_detection(bool value);
  private:
  bool _internal_enable_bottom_detection() const;
  void _internal_set_enable_bottom_detection(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetBottomDetectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_bottom_detection_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetBottomDetectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetBottomDetectionResponse) */ {
 public:
  inline SetBottomDetectionResponse() : SetBottomDetectionResponse(nullptr) {}
  ~SetBottomDetectionResponse() override;
  explicit constexpr SetBottomDetectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetBottomDetectionResponse(const SetBottomDetectionResponse& from);
  SetBottomDetectionResponse(SetBottomDetectionResponse&& from) noexcept
    : SetBottomDetectionResponse() {
    *this = ::std::move(from);
  }

  inline SetBottomDetectionResponse& operator=(const SetBottomDetectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetBottomDetectionResponse& operator=(SetBottomDetectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetBottomDetectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetBottomDetectionResponse* internal_default_instance() {
    return reinterpret_cast<const SetBottomDetectionResponse*>(
               &_SetBottomDetectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetBottomDetectionResponse& a, SetBottomDetectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetBottomDetectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetBottomDetectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetBottomDetectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetBottomDetectionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetBottomDetectionResponse& from);
  void MergeFrom(const SetBottomDetectionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetBottomDetectionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetBottomDetectionResponse";
  }
  protected:
  explicit SetBottomDetectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .proto.nav_api.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::proto::nav_api::RequestResult& result() const;
  PROTOBUF_NODISCARD ::proto::nav_api::RequestResult* release_result();
  ::proto::nav_api::RequestResult* mutable_result();
  void set_allocated_result(::proto::nav_api::RequestResult* result);
  private:
  const ::proto::nav_api::RequestResult& _internal_result() const;
  ::proto::nav_api::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::proto::nav_api::RequestResult* result);
  ::proto::nav_api::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetBottomDetectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nav_api::RequestResult* result_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetInWaterSquelchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetInWaterSquelchRequest) */ {
 public:
  inline SetInWaterSquelchRequest() : SetInWaterSquelchRequest(nullptr) {}
  ~SetInWaterSquelchRequest() override;
  explicit constexpr SetInWaterSquelchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetInWaterSquelchRequest(const SetInWaterSquelchRequest& from);
  SetInWaterSquelchRequest(SetInWaterSquelchRequest&& from) noexcept
    : SetInWaterSquelchRequest() {
    *this = ::std::move(from);
  }

  inline SetInWaterSquelchRequest& operator=(const SetInWaterSquelchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetInWaterSquelchRequest& operator=(SetInWaterSquelchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetInWaterSquelchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetInWaterSquelchRequest* internal_default_instance() {
    return reinterpret_cast<const SetInWaterSquelchRequest*>(
               &_SetInWaterSquelchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetInWaterSquelchRequest& a, SetInWaterSquelchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetInWaterSquelchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetInWaterSquelchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetInWaterSquelchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetInWaterSquelchRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetInWaterSquelchRequest& from);
  void MergeFrom(const SetInWaterSquelchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetInWaterSquelchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetInWaterSquelchRequest";
  }
  protected:
  explicit SetInWaterSquelchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewSquelchValFieldNumber = 1,
  };
  // optional float new_squelch_val = 1;
  bool has_new_squelch_val() const;
  private:
  bool _internal_has_new_squelch_val() const;
  public:
  void clear_new_squelch_val();
  float new_squelch_val() const;
  void set_new_squelch_val(float value);
  private:
  float _internal_new_squelch_val() const;
  void _internal_set_new_squelch_val(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetInWaterSquelchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float new_squelch_val_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetInWaterSquelchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetInWaterSquelchResponse) */ {
 public:
  inline SetInWaterSquelchResponse() : SetInWaterSquelchResponse(nullptr) {}
  ~SetInWaterSquelchResponse() override;
  explicit constexpr SetInWaterSquelchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetInWaterSquelchResponse(const SetInWaterSquelchResponse& from);
  SetInWaterSquelchResponse(SetInWaterSquelchResponse&& from) noexcept
    : SetInWaterSquelchResponse() {
    *this = ::std::move(from);
  }

  inline SetInWaterSquelchResponse& operator=(const SetInWaterSquelchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetInWaterSquelchResponse& operator=(SetInWaterSquelchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetInWaterSquelchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetInWaterSquelchResponse* internal_default_instance() {
    return reinterpret_cast<const SetInWaterSquelchResponse*>(
               &_SetInWaterSquelchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SetInWaterSquelchResponse& a, SetInWaterSquelchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetInWaterSquelchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetInWaterSquelchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetInWaterSquelchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetInWaterSquelchResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetInWaterSquelchResponse& from);
  void MergeFrom(const SetInWaterSquelchResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetInWaterSquelchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetInWaterSquelchResponse";
  }
  protected:
  explicit SetInWaterSquelchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .proto.nav_api.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::proto::nav_api::RequestResult& result() const;
  PROTOBUF_NODISCARD ::proto::nav_api::RequestResult* release_result();
  ::proto::nav_api::RequestResult* mutable_result();
  void set_allocated_result(::proto::nav_api::RequestResult* result);
  private:
  const ::proto::nav_api::RequestResult& _internal_result() const;
  ::proto::nav_api::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::proto::nav_api::RequestResult* result);
  ::proto::nav_api::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetInWaterSquelchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nav_api::RequestResult* result_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetSquelchlessInWaterDetectorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetSquelchlessInWaterDetectorRequest) */ {
 public:
  inline SetSquelchlessInWaterDetectorRequest() : SetSquelchlessInWaterDetectorRequest(nullptr) {}
  ~SetSquelchlessInWaterDetectorRequest() override;
  explicit constexpr SetSquelchlessInWaterDetectorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSquelchlessInWaterDetectorRequest(const SetSquelchlessInWaterDetectorRequest& from);
  SetSquelchlessInWaterDetectorRequest(SetSquelchlessInWaterDetectorRequest&& from) noexcept
    : SetSquelchlessInWaterDetectorRequest() {
    *this = ::std::move(from);
  }

  inline SetSquelchlessInWaterDetectorRequest& operator=(const SetSquelchlessInWaterDetectorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSquelchlessInWaterDetectorRequest& operator=(SetSquelchlessInWaterDetectorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetSquelchlessInWaterDetectorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSquelchlessInWaterDetectorRequest* internal_default_instance() {
    return reinterpret_cast<const SetSquelchlessInWaterDetectorRequest*>(
               &_SetSquelchlessInWaterDetectorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetSquelchlessInWaterDetectorRequest& a, SetSquelchlessInWaterDetectorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSquelchlessInWaterDetectorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSquelchlessInWaterDetectorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSquelchlessInWaterDetectorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSquelchlessInWaterDetectorRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetSquelchlessInWaterDetectorRequest& from);
  void MergeFrom(const SetSquelchlessInWaterDetectorRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetSquelchlessInWaterDetectorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetSquelchlessInWaterDetectorRequest";
  }
  protected:
  explicit SetSquelchlessInWaterDetectorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableSquelchlessDetectionFieldNumber = 1,
  };
  // optional bool enable_squelchless_detection = 1;
  bool has_enable_squelchless_detection() const;
  private:
  bool _internal_has_enable_squelchless_detection() const;
  public:
  void clear_enable_squelchless_detection();
  bool enable_squelchless_detection() const;
  void set_enable_squelchless_detection(bool value);
  private:
  bool _internal_enable_squelchless_detection() const;
  void _internal_set_enable_squelchless_detection(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetSquelchlessInWaterDetectorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_squelchless_detection_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetSquelchlessInWaterDetectorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetSquelchlessInWaterDetectorResponse) */ {
 public:
  inline SetSquelchlessInWaterDetectorResponse() : SetSquelchlessInWaterDetectorResponse(nullptr) {}
  ~SetSquelchlessInWaterDetectorResponse() override;
  explicit constexpr SetSquelchlessInWaterDetectorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSquelchlessInWaterDetectorResponse(const SetSquelchlessInWaterDetectorResponse& from);
  SetSquelchlessInWaterDetectorResponse(SetSquelchlessInWaterDetectorResponse&& from) noexcept
    : SetSquelchlessInWaterDetectorResponse() {
    *this = ::std::move(from);
  }

  inline SetSquelchlessInWaterDetectorResponse& operator=(const SetSquelchlessInWaterDetectorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSquelchlessInWaterDetectorResponse& operator=(SetSquelchlessInWaterDetectorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetSquelchlessInWaterDetectorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSquelchlessInWaterDetectorResponse* internal_default_instance() {
    return reinterpret_cast<const SetSquelchlessInWaterDetectorResponse*>(
               &_SetSquelchlessInWaterDetectorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SetSquelchlessInWaterDetectorResponse& a, SetSquelchlessInWaterDetectorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSquelchlessInWaterDetectorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSquelchlessInWaterDetectorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSquelchlessInWaterDetectorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSquelchlessInWaterDetectorResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetSquelchlessInWaterDetectorResponse& from);
  void MergeFrom(const SetSquelchlessInWaterDetectorResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetSquelchlessInWaterDetectorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetSquelchlessInWaterDetectorResponse";
  }
  protected:
  explicit SetSquelchlessInWaterDetectorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .proto.nav_api.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::proto::nav_api::RequestResult& result() const;
  PROTOBUF_NODISCARD ::proto::nav_api::RequestResult* release_result();
  ::proto::nav_api::RequestResult* mutable_result();
  void set_allocated_result(::proto::nav_api::RequestResult* result);
  private:
  const ::proto::nav_api::RequestResult& _internal_result() const;
  ::proto::nav_api::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::proto::nav_api::RequestResult* result);
  ::proto::nav_api::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetSquelchlessInWaterDetectorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nav_api::RequestResult* result_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class VesselInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.VesselInfo) */ {
 public:
  inline VesselInfo() : VesselInfo(nullptr) {}
  ~VesselInfo() override;
  explicit constexpr VesselInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VesselInfo(const VesselInfo& from);
  VesselInfo(VesselInfo&& from) noexcept
    : VesselInfo() {
    *this = ::std::move(from);
  }

  inline VesselInfo& operator=(const VesselInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VesselInfo& operator=(VesselInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VesselInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VesselInfo* internal_default_instance() {
    return reinterpret_cast<const VesselInfo*>(
               &_VesselInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VesselInfo& a, VesselInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VesselInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VesselInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VesselInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VesselInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VesselInfo& from);
  void MergeFrom(const VesselInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VesselInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.VesselInfo";
  }
  protected:
  explicit VesselInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDraftFieldNumber = 1,
    kKeelOffsetFieldNumber = 2,
  };
  // optional float draft = 1;
  bool has_draft() const;
  private:
  bool _internal_has_draft() const;
  public:
  void clear_draft();
  float draft() const;
  void set_draft(float value);
  private:
  float _internal_draft() const;
  void _internal_set_draft(float value);
  public:

  // optional float keel_offset = 2;
  bool has_keel_offset() const;
  private:
  bool _internal_has_keel_offset() const;
  public:
  void clear_keel_offset();
  float keel_offset() const;
  void set_keel_offset(float value);
  private:
  float _internal_keel_offset() const;
  void _internal_set_keel_offset(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.VesselInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float draft_;
  float keel_offset_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetVesselInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.GetVesselInfoRequest) */ {
 public:
  inline GetVesselInfoRequest() : GetVesselInfoRequest(nullptr) {}
  ~GetVesselInfoRequest() override;
  explicit constexpr GetVesselInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVesselInfoRequest(const GetVesselInfoRequest& from);
  GetVesselInfoRequest(GetVesselInfoRequest&& from) noexcept
    : GetVesselInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetVesselInfoRequest& operator=(const GetVesselInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVesselInfoRequest& operator=(GetVesselInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetVesselInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVesselInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetVesselInfoRequest*>(
               &_GetVesselInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetVesselInfoRequest& a, GetVesselInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVesselInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVesselInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVesselInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVesselInfoRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetVesselInfoRequest& from);
  void MergeFrom(const GetVesselInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetVesselInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.GetVesselInfoRequest";
  }
  protected:
  explicit GetVesselInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.nav_api.GetVesselInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetVesselInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.GetVesselInfoResponse) */ {
 public:
  inline GetVesselInfoResponse() : GetVesselInfoResponse(nullptr) {}
  ~GetVesselInfoResponse() override;
  explicit constexpr GetVesselInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVesselInfoResponse(const GetVesselInfoResponse& from);
  GetVesselInfoResponse(GetVesselInfoResponse&& from) noexcept
    : GetVesselInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetVesselInfoResponse& operator=(const GetVesselInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVesselInfoResponse& operator=(GetVesselInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetVesselInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVesselInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetVesselInfoResponse*>(
               &_GetVesselInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetVesselInfoResponse& a, GetVesselInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVesselInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVesselInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVesselInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVesselInfoResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetVesselInfoResponse& from);
  void MergeFrom(const GetVesselInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetVesselInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.GetVesselInfoResponse";
  }
  protected:
  explicit GetVesselInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // optional .proto.nav_api.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::proto::nav_api::RequestResult& result() const;
  PROTOBUF_NODISCARD ::proto::nav_api::RequestResult* release_result();
  ::proto::nav_api::RequestResult* mutable_result();
  void set_allocated_result(::proto::nav_api::RequestResult* result);
  private:
  const ::proto::nav_api::RequestResult& _internal_result() const;
  ::proto::nav_api::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::proto::nav_api::RequestResult* result);
  ::proto::nav_api::RequestResult* unsafe_arena_release_result();

  // optional .proto.nav_api.VesselInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::proto::nav_api::VesselInfo& info() const;
  PROTOBUF_NODISCARD ::proto::nav_api::VesselInfo* release_info();
  ::proto::nav_api::VesselInfo* mutable_info();
  void set_allocated_info(::proto::nav_api::VesselInfo* info);
  private:
  const ::proto::nav_api::VesselInfo& _internal_info() const;
  ::proto::nav_api::VesselInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::proto::nav_api::VesselInfo* info);
  ::proto::nav_api::VesselInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:proto.nav_api.GetVesselInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nav_api::RequestResult* result_;
  ::proto::nav_api::VesselInfo* info_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetDraftRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetDraftRequest) */ {
 public:
  inline SetDraftRequest() : SetDraftRequest(nullptr) {}
  ~SetDraftRequest() override;
  explicit constexpr SetDraftRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDraftRequest(const SetDraftRequest& from);
  SetDraftRequest(SetDraftRequest&& from) noexcept
    : SetDraftRequest() {
    *this = ::std::move(from);
  }

  inline SetDraftRequest& operator=(const SetDraftRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDraftRequest& operator=(SetDraftRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetDraftRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDraftRequest* internal_default_instance() {
    return reinterpret_cast<const SetDraftRequest*>(
               &_SetDraftRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SetDraftRequest& a, SetDraftRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDraftRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDraftRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDraftRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetDraftRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetDraftRequest& from);
  void MergeFrom(const SetDraftRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetDraftRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetDraftRequest";
  }
  protected:
  explicit SetDraftRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewDraftFieldNumber = 1,
  };
  // optional float new_draft = 1;
  bool has_new_draft() const;
  private:
  bool _internal_has_new_draft() const;
  public:
  void clear_new_draft();
  float new_draft() const;
  void set_new_draft(float value);
  private:
  float _internal_new_draft() const;
  void _internal_set_new_draft(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetDraftRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float new_draft_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetDraftResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetDraftResponse) */ {
 public:
  inline SetDraftResponse() : SetDraftResponse(nullptr) {}
  ~SetDraftResponse() override;
  explicit constexpr SetDraftResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDraftResponse(const SetDraftResponse& from);
  SetDraftResponse(SetDraftResponse&& from) noexcept
    : SetDraftResponse() {
    *this = ::std::move(from);
  }

  inline SetDraftResponse& operator=(const SetDraftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDraftResponse& operator=(SetDraftResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetDraftResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDraftResponse* internal_default_instance() {
    return reinterpret_cast<const SetDraftResponse*>(
               &_SetDraftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SetDraftResponse& a, SetDraftResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDraftResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDraftResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDraftResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetDraftResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetDraftResponse& from);
  void MergeFrom(const SetDraftResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetDraftResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetDraftResponse";
  }
  protected:
  explicit SetDraftResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .proto.nav_api.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::proto::nav_api::RequestResult& result() const;
  PROTOBUF_NODISCARD ::proto::nav_api::RequestResult* release_result();
  ::proto::nav_api::RequestResult* mutable_result();
  void set_allocated_result(::proto::nav_api::RequestResult* result);
  private:
  const ::proto::nav_api::RequestResult& _internal_result() const;
  ::proto::nav_api::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::proto::nav_api::RequestResult* result);
  ::proto::nav_api::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetDraftResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nav_api::RequestResult* result_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetKeelOffsetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetKeelOffsetRequest) */ {
 public:
  inline SetKeelOffsetRequest() : SetKeelOffsetRequest(nullptr) {}
  ~SetKeelOffsetRequest() override;
  explicit constexpr SetKeelOffsetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetKeelOffsetRequest(const SetKeelOffsetRequest& from);
  SetKeelOffsetRequest(SetKeelOffsetRequest&& from) noexcept
    : SetKeelOffsetRequest() {
    *this = ::std::move(from);
  }

  inline SetKeelOffsetRequest& operator=(const SetKeelOffsetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetKeelOffsetRequest& operator=(SetKeelOffsetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetKeelOffsetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetKeelOffsetRequest* internal_default_instance() {
    return reinterpret_cast<const SetKeelOffsetRequest*>(
               &_SetKeelOffsetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SetKeelOffsetRequest& a, SetKeelOffsetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetKeelOffsetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetKeelOffsetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetKeelOffsetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetKeelOffsetRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetKeelOffsetRequest& from);
  void MergeFrom(const SetKeelOffsetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetKeelOffsetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetKeelOffsetRequest";
  }
  protected:
  explicit SetKeelOffsetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewKeelOffsetFieldNumber = 1,
  };
  // optional float new_keel_offset = 1;
  bool has_new_keel_offset() const;
  private:
  bool _internal_has_new_keel_offset() const;
  public:
  void clear_new_keel_offset();
  float new_keel_offset() const;
  void set_new_keel_offset(float value);
  private:
  float _internal_new_keel_offset() const;
  void _internal_set_new_keel_offset(float value);
  public:

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetKeelOffsetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float new_keel_offset_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetKeelOffsetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.nav_api.SetKeelOffsetResponse) */ {
 public:
  inline SetKeelOffsetResponse() : SetKeelOffsetResponse(nullptr) {}
  ~SetKeelOffsetResponse() override;
  explicit constexpr SetKeelOffsetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetKeelOffsetResponse(const SetKeelOffsetResponse& from);
  SetKeelOffsetResponse(SetKeelOffsetResponse&& from) noexcept
    : SetKeelOffsetResponse() {
    *this = ::std::move(from);
  }

  inline SetKeelOffsetResponse& operator=(const SetKeelOffsetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetKeelOffsetResponse& operator=(SetKeelOffsetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetKeelOffsetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetKeelOffsetResponse* internal_default_instance() {
    return reinterpret_cast<const SetKeelOffsetResponse*>(
               &_SetKeelOffsetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SetKeelOffsetResponse& a, SetKeelOffsetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetKeelOffsetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetKeelOffsetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetKeelOffsetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetKeelOffsetResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetKeelOffsetResponse& from);
  void MergeFrom(const SetKeelOffsetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetKeelOffsetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.nav_api.SetKeelOffsetResponse";
  }
  protected:
  explicit SetKeelOffsetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .proto.nav_api.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::proto::nav_api::RequestResult& result() const;
  PROTOBUF_NODISCARD ::proto::nav_api::RequestResult* release_result();
  ::proto::nav_api::RequestResult* mutable_result();
  void set_allocated_result(::proto::nav_api::RequestResult* result);
  private:
  const ::proto::nav_api::RequestResult& _internal_result() const;
  ::proto::nav_api::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::proto::nav_api::RequestResult* result);
  ::proto::nav_api::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:proto.nav_api.SetKeelOffsetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::nav_api::RequestResult* result_;
  friend struct ::TableStruct_nav_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestResult

// optional .proto.time.Time time = 1;
inline bool RequestResult::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool RequestResult::has_time() const {
  return _internal_has_time();
}
inline const ::proto::time::Time& RequestResult::_internal_time() const {
  const ::proto::time::Time* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::time::Time&>(
      ::proto::time::_Time_default_instance_);
}
inline const ::proto::time::Time& RequestResult::time() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.RequestResult.time)
  return _internal_time();
}
inline void RequestResult::unsafe_arena_set_allocated_time(
    ::proto::time::Time* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.RequestResult.time)
}
inline ::proto::time::Time* RequestResult::release_time() {
  _has_bits_[0] &= ~0x00000002u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::time::Time* RequestResult::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:proto.nav_api.RequestResult.time)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::proto::time::Time* RequestResult::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000002u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::time::Time>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::proto::time::Time* RequestResult::mutable_time() {
  ::proto::time::Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.RequestResult.time)
  return _msg;
}
inline void RequestResult::set_allocated_time(::proto::time::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.RequestResult.time)
}

// optional .proto.nav_api.RequestResult.ResultCode code = 2;
inline bool RequestResult::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestResult::has_code() const {
  return _internal_has_code();
}
inline void RequestResult::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::nav_api::RequestResult_ResultCode RequestResult::_internal_code() const {
  return static_cast< ::proto::nav_api::RequestResult_ResultCode >(code_);
}
inline ::proto::nav_api::RequestResult_ResultCode RequestResult::code() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.RequestResult.code)
  return _internal_code();
}
inline void RequestResult::_internal_set_code(::proto::nav_api::RequestResult_ResultCode value) {
  assert(::proto::nav_api::RequestResult_ResultCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  code_ = value;
}
inline void RequestResult::set_code(::proto::nav_api::RequestResult_ResultCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.RequestResult.code)
}

// optional string result_detail = 3;
inline bool RequestResult::_internal_has_result_detail() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestResult::has_result_detail() const {
  return _internal_has_result_detail();
}
inline void RequestResult::clear_result_detail() {
  result_detail_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestResult::result_detail() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.RequestResult.result_detail)
  return _internal_result_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestResult::set_result_detail(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 result_detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.nav_api.RequestResult.result_detail)
}
inline std::string* RequestResult::mutable_result_detail() {
  std::string* _s = _internal_mutable_result_detail();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.RequestResult.result_detail)
  return _s;
}
inline const std::string& RequestResult::_internal_result_detail() const {
  return result_detail_.Get();
}
inline void RequestResult::_internal_set_result_detail(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  result_detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestResult::_internal_mutable_result_detail() {
  _has_bits_[0] |= 0x00000001u;
  return result_detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestResult::release_result_detail() {
  // @@protoc_insertion_point(field_release:proto.nav_api.RequestResult.result_detail)
  if (!_internal_has_result_detail()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = result_detail_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_detail_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_detail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestResult::set_allocated_result_detail(std::string* result_detail) {
  if (result_detail != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result_detail,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_detail_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_detail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.RequestResult.result_detail)
}

// -------------------------------------------------------------------

// HydrophoneData

// optional .proto.time.Time time = 1;
inline bool HydrophoneData::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool HydrophoneData::has_time() const {
  return _internal_has_time();
}
inline const ::proto::time::Time& HydrophoneData::_internal_time() const {
  const ::proto::time::Time* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::time::Time&>(
      ::proto::time::_Time_default_instance_);
}
inline const ::proto::time::Time& HydrophoneData::time() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.HydrophoneData.time)
  return _internal_time();
}
inline void HydrophoneData::unsafe_arena_set_allocated_time(
    ::proto::time::Time* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.HydrophoneData.time)
}
inline ::proto::time::Time* HydrophoneData::release_time() {
  _has_bits_[0] &= ~0x00000004u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::time::Time* HydrophoneData::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:proto.nav_api.HydrophoneData.time)
  _has_bits_[0] &= ~0x00000004u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::proto::time::Time* HydrophoneData::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000004u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::time::Time>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::proto::time::Time* HydrophoneData::mutable_time() {
  ::proto::time::Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.HydrophoneData.time)
  return _msg;
}
inline void HydrophoneData::set_allocated_time(::proto::time::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.HydrophoneData.time)
}

// optional .proto.array.ArrayData raw_timeseries = 2;
inline bool HydrophoneData::_internal_has_raw_timeseries() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || raw_timeseries_ != nullptr);
  return value;
}
inline bool HydrophoneData::has_raw_timeseries() const {
  return _internal_has_raw_timeseries();
}
inline const ::proto::array::ArrayData& HydrophoneData::_internal_raw_timeseries() const {
  const ::proto::array::ArrayData* p = raw_timeseries_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::array::ArrayData&>(
      ::proto::array::_ArrayData_default_instance_);
}
inline const ::proto::array::ArrayData& HydrophoneData::raw_timeseries() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.HydrophoneData.raw_timeseries)
  return _internal_raw_timeseries();
}
inline void HydrophoneData::unsafe_arena_set_allocated_raw_timeseries(
    ::proto::array::ArrayData* raw_timeseries) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_timeseries_);
  }
  raw_timeseries_ = raw_timeseries;
  if (raw_timeseries) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.HydrophoneData.raw_timeseries)
}
inline ::proto::array::ArrayData* HydrophoneData::release_raw_timeseries() {
  _has_bits_[0] &= ~0x00000008u;
  ::proto::array::ArrayData* temp = raw_timeseries_;
  raw_timeseries_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::array::ArrayData* HydrophoneData::unsafe_arena_release_raw_timeseries() {
  // @@protoc_insertion_point(field_release:proto.nav_api.HydrophoneData.raw_timeseries)
  _has_bits_[0] &= ~0x00000008u;
  ::proto::array::ArrayData* temp = raw_timeseries_;
  raw_timeseries_ = nullptr;
  return temp;
}
inline ::proto::array::ArrayData* HydrophoneData::_internal_mutable_raw_timeseries() {
  _has_bits_[0] |= 0x00000008u;
  if (raw_timeseries_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::array::ArrayData>(GetArenaForAllocation());
    raw_timeseries_ = p;
  }
  return raw_timeseries_;
}
inline ::proto::array::ArrayData* HydrophoneData::mutable_raw_timeseries() {
  ::proto::array::ArrayData* _msg = _internal_mutable_raw_timeseries();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.HydrophoneData.raw_timeseries)
  return _msg;
}
inline void HydrophoneData::set_allocated_raw_timeseries(::proto::array::ArrayData* raw_timeseries) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_timeseries_);
  }
  if (raw_timeseries) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_timeseries));
    if (message_arena != submessage_arena) {
      raw_timeseries = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_timeseries, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  raw_timeseries_ = raw_timeseries;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.HydrophoneData.raw_timeseries)
}

// optional int32 num_hor_phones = 3;
inline bool HydrophoneData::_internal_has_num_hor_phones() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HydrophoneData::has_num_hor_phones() const {
  return _internal_has_num_hor_phones();
}
inline void HydrophoneData::clear_num_hor_phones() {
  num_hor_phones_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t HydrophoneData::_internal_num_hor_phones() const {
  return num_hor_phones_;
}
inline int32_t HydrophoneData::num_hor_phones() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.HydrophoneData.num_hor_phones)
  return _internal_num_hor_phones();
}
inline void HydrophoneData::_internal_set_num_hor_phones(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  num_hor_phones_ = value;
}
inline void HydrophoneData::set_num_hor_phones(int32_t value) {
  _internal_set_num_hor_phones(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.HydrophoneData.num_hor_phones)
}

// optional int32 num_ver_phones = 4;
inline bool HydrophoneData::_internal_has_num_ver_phones() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool HydrophoneData::has_num_ver_phones() const {
  return _internal_has_num_ver_phones();
}
inline void HydrophoneData::clear_num_ver_phones() {
  num_ver_phones_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t HydrophoneData::_internal_num_ver_phones() const {
  return num_ver_phones_;
}
inline int32_t HydrophoneData::num_ver_phones() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.HydrophoneData.num_ver_phones)
  return _internal_num_ver_phones();
}
inline void HydrophoneData::_internal_set_num_ver_phones(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  num_ver_phones_ = value;
}
inline void HydrophoneData::set_num_ver_phones(int32_t value) {
  _internal_set_num_ver_phones(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.HydrophoneData.num_ver_phones)
}

// optional string serial = 5;
inline bool HydrophoneData::_internal_has_serial() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HydrophoneData::has_serial() const {
  return _internal_has_serial();
}
inline void HydrophoneData::clear_serial() {
  serial_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HydrophoneData::serial() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.HydrophoneData.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydrophoneData::set_serial(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.nav_api.HydrophoneData.serial)
}
inline std::string* HydrophoneData::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.HydrophoneData.serial)
  return _s;
}
inline const std::string& HydrophoneData::_internal_serial() const {
  return serial_.Get();
}
inline void HydrophoneData::_internal_set_serial(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HydrophoneData::_internal_mutable_serial() {
  _has_bits_[0] |= 0x00000001u;
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HydrophoneData::release_serial() {
  // @@protoc_insertion_point(field_release:proto.nav_api.HydrophoneData.serial)
  if (!_internal_has_serial()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = serial_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydrophoneData::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.HydrophoneData.serial)
}

// optional string transmit_id = 6;
inline bool HydrophoneData::_internal_has_transmit_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HydrophoneData::has_transmit_id() const {
  return _internal_has_transmit_id();
}
inline void HydrophoneData::clear_transmit_id() {
  transmit_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HydrophoneData::transmit_id() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.HydrophoneData.transmit_id)
  return _internal_transmit_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydrophoneData::set_transmit_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 transmit_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.nav_api.HydrophoneData.transmit_id)
}
inline std::string* HydrophoneData::mutable_transmit_id() {
  std::string* _s = _internal_mutable_transmit_id();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.HydrophoneData.transmit_id)
  return _s;
}
inline const std::string& HydrophoneData::_internal_transmit_id() const {
  return transmit_id_.Get();
}
inline void HydrophoneData::_internal_set_transmit_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  transmit_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HydrophoneData::_internal_mutable_transmit_id() {
  _has_bits_[0] |= 0x00000002u;
  return transmit_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HydrophoneData::release_transmit_id() {
  // @@protoc_insertion_point(field_release:proto.nav_api.HydrophoneData.transmit_id)
  if (!_internal_has_transmit_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = transmit_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transmit_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transmit_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydrophoneData::set_allocated_transmit_id(std::string* transmit_id) {
  if (transmit_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  transmit_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transmit_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transmit_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transmit_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.HydrophoneData.transmit_id)
}

// -------------------------------------------------------------------

// TargetData

// optional .proto.time.Time time = 1;
inline bool TargetData::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool TargetData::has_time() const {
  return _internal_has_time();
}
inline const ::proto::time::Time& TargetData::_internal_time() const {
  const ::proto::time::Time* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::time::Time&>(
      ::proto::time::_Time_default_instance_);
}
inline const ::proto::time::Time& TargetData::time() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.time)
  return _internal_time();
}
inline void TargetData::unsafe_arena_set_allocated_time(
    ::proto::time::Time* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.TargetData.time)
}
inline ::proto::time::Time* TargetData::release_time() {
  _has_bits_[0] &= ~0x00000002u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::time::Time* TargetData::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:proto.nav_api.TargetData.time)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::proto::time::Time* TargetData::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000002u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::time::Time>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::proto::time::Time* TargetData::mutable_time() {
  ::proto::time::Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.TargetData.time)
  return _msg;
}
inline void TargetData::set_allocated_time(::proto::time::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.TargetData.time)
}

// optional string serial = 2;
inline bool TargetData::_internal_has_serial() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TargetData::has_serial() const {
  return _internal_has_serial();
}
inline void TargetData::clear_serial() {
  serial_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TargetData::serial() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetData::set_serial(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.nav_api.TargetData.serial)
}
inline std::string* TargetData::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.TargetData.serial)
  return _s;
}
inline const std::string& TargetData::_internal_serial() const {
  return serial_.Get();
}
inline void TargetData::_internal_set_serial(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetData::_internal_mutable_serial() {
  _has_bits_[0] |= 0x00000001u;
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetData::release_serial() {
  // @@protoc_insertion_point(field_release:proto.nav_api.TargetData.serial)
  if (!_internal_has_serial()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = serial_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TargetData::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.TargetData.serial)
}

// optional .proto.nav_info.Heading heading = 4;
inline bool TargetData::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || heading_ != nullptr);
  return value;
}
inline bool TargetData::has_heading() const {
  return _internal_has_heading();
}
inline const ::proto::nav_info::Heading& TargetData::_internal_heading() const {
  const ::proto::nav_info::Heading* p = heading_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_info::Heading&>(
      ::proto::nav_info::_Heading_default_instance_);
}
inline const ::proto::nav_info::Heading& TargetData::heading() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.heading)
  return _internal_heading();
}
inline void TargetData::unsafe_arena_set_allocated_heading(
    ::proto::nav_info::Heading* heading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heading_);
  }
  heading_ = heading;
  if (heading) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.TargetData.heading)
}
inline ::proto::nav_info::Heading* TargetData::release_heading() {
  _has_bits_[0] &= ~0x00000004u;
  ::proto::nav_info::Heading* temp = heading_;
  heading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_info::Heading* TargetData::unsafe_arena_release_heading() {
  // @@protoc_insertion_point(field_release:proto.nav_api.TargetData.heading)
  _has_bits_[0] &= ~0x00000004u;
  ::proto::nav_info::Heading* temp = heading_;
  heading_ = nullptr;
  return temp;
}
inline ::proto::nav_info::Heading* TargetData::_internal_mutable_heading() {
  _has_bits_[0] |= 0x00000004u;
  if (heading_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_info::Heading>(GetArenaForAllocation());
    heading_ = p;
  }
  return heading_;
}
inline ::proto::nav_info::Heading* TargetData::mutable_heading() {
  ::proto::nav_info::Heading* _msg = _internal_mutable_heading();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.TargetData.heading)
  return _msg;
}
inline void TargetData::set_allocated_heading(::proto::nav_info::Heading* heading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heading_);
  }
  if (heading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heading));
    if (message_arena != submessage_arena) {
      heading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heading, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  heading_ = heading;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.TargetData.heading)
}

// optional .proto.nav_info.Position position = 5;
inline bool TargetData::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool TargetData::has_position() const {
  return _internal_has_position();
}
inline const ::proto::nav_info::Position& TargetData::_internal_position() const {
  const ::proto::nav_info::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_info::Position&>(
      ::proto::nav_info::_Position_default_instance_);
}
inline const ::proto::nav_info::Position& TargetData::position() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.position)
  return _internal_position();
}
inline void TargetData::unsafe_arena_set_allocated_position(
    ::proto::nav_info::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.TargetData.position)
}
inline ::proto::nav_info::Position* TargetData::release_position() {
  _has_bits_[0] &= ~0x00000008u;
  ::proto::nav_info::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_info::Position* TargetData::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:proto.nav_api.TargetData.position)
  _has_bits_[0] &= ~0x00000008u;
  ::proto::nav_info::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::proto::nav_info::Position* TargetData::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000008u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_info::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::proto::nav_info::Position* TargetData::mutable_position() {
  ::proto::nav_info::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.TargetData.position)
  return _msg;
}
inline void TargetData::set_allocated_position(::proto::nav_info::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.TargetData.position)
}

// repeated .proto.nav_api.Bin bottom = 6;
inline int TargetData::_internal_bottom_size() const {
  return bottom_.size();
}
inline int TargetData::bottom_size() const {
  return _internal_bottom_size();
}
inline void TargetData::clear_bottom() {
  bottom_.Clear();
}
inline ::proto::nav_api::Bin* TargetData::mutable_bottom(int index) {
  // @@protoc_insertion_point(field_mutable:proto.nav_api.TargetData.bottom)
  return bottom_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin >*
TargetData::mutable_bottom() {
  // @@protoc_insertion_point(field_mutable_list:proto.nav_api.TargetData.bottom)
  return &bottom_;
}
inline const ::proto::nav_api::Bin& TargetData::_internal_bottom(int index) const {
  return bottom_.Get(index);
}
inline const ::proto::nav_api::Bin& TargetData::bottom(int index) const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.bottom)
  return _internal_bottom(index);
}
inline ::proto::nav_api::Bin* TargetData::_internal_add_bottom() {
  return bottom_.Add();
}
inline ::proto::nav_api::Bin* TargetData::add_bottom() {
  ::proto::nav_api::Bin* _add = _internal_add_bottom();
  // @@protoc_insertion_point(field_add:proto.nav_api.TargetData.bottom)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin >&
TargetData::bottom() const {
  // @@protoc_insertion_point(field_list:proto.nav_api.TargetData.bottom)
  return bottom_;
}

// repeated .proto.nav_api.Group groups = 7;
inline int TargetData::_internal_groups_size() const {
  return groups_.size();
}
inline int TargetData::groups_size() const {
  return _internal_groups_size();
}
inline void TargetData::clear_groups() {
  groups_.Clear();
}
inline ::proto::nav_api::Group* TargetData::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:proto.nav_api.TargetData.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Group >*
TargetData::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:proto.nav_api.TargetData.groups)
  return &groups_;
}
inline const ::proto::nav_api::Group& TargetData::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const ::proto::nav_api::Group& TargetData::groups(int index) const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.groups)
  return _internal_groups(index);
}
inline ::proto::nav_api::Group* TargetData::_internal_add_groups() {
  return groups_.Add();
}
inline ::proto::nav_api::Group* TargetData::add_groups() {
  ::proto::nav_api::Group* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:proto.nav_api.TargetData.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Group >&
TargetData::groups() const {
  // @@protoc_insertion_point(field_list:proto.nav_api.TargetData.groups)
  return groups_;
}

// optional .proto.grid_description.GridDescription grid_description = 8;
inline bool TargetData::_internal_has_grid_description() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || grid_description_ != nullptr);
  return value;
}
inline bool TargetData::has_grid_description() const {
  return _internal_has_grid_description();
}
inline const ::proto::grid_description::GridDescription& TargetData::_internal_grid_description() const {
  const ::proto::grid_description::GridDescription* p = grid_description_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::grid_description::GridDescription&>(
      ::proto::grid_description::_GridDescription_default_instance_);
}
inline const ::proto::grid_description::GridDescription& TargetData::grid_description() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.grid_description)
  return _internal_grid_description();
}
inline void TargetData::unsafe_arena_set_allocated_grid_description(
    ::proto::grid_description::GridDescription* grid_description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grid_description_);
  }
  grid_description_ = grid_description;
  if (grid_description) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.TargetData.grid_description)
}
inline ::proto::grid_description::GridDescription* TargetData::release_grid_description() {
  _has_bits_[0] &= ~0x00000010u;
  ::proto::grid_description::GridDescription* temp = grid_description_;
  grid_description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::grid_description::GridDescription* TargetData::unsafe_arena_release_grid_description() {
  // @@protoc_insertion_point(field_release:proto.nav_api.TargetData.grid_description)
  _has_bits_[0] &= ~0x00000010u;
  ::proto::grid_description::GridDescription* temp = grid_description_;
  grid_description_ = nullptr;
  return temp;
}
inline ::proto::grid_description::GridDescription* TargetData::_internal_mutable_grid_description() {
  _has_bits_[0] |= 0x00000010u;
  if (grid_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::grid_description::GridDescription>(GetArenaForAllocation());
    grid_description_ = p;
  }
  return grid_description_;
}
inline ::proto::grid_description::GridDescription* TargetData::mutable_grid_description() {
  ::proto::grid_description::GridDescription* _msg = _internal_mutable_grid_description();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.TargetData.grid_description)
  return _msg;
}
inline void TargetData::set_allocated_grid_description(::proto::grid_description::GridDescription* grid_description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(grid_description_);
  }
  if (grid_description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grid_description));
    if (message_arena != submessage_arena) {
      grid_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grid_description, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  grid_description_ = grid_description;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.TargetData.grid_description)
}

// optional double max_depth = 9;
inline bool TargetData::_internal_has_max_depth() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TargetData::has_max_depth() const {
  return _internal_has_max_depth();
}
inline void TargetData::clear_max_depth() {
  max_depth_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double TargetData::_internal_max_depth() const {
  return max_depth_;
}
inline double TargetData::max_depth() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.max_depth)
  return _internal_max_depth();
}
inline void TargetData::_internal_set_max_depth(double value) {
  _has_bits_[0] |= 0x00000020u;
  max_depth_ = value;
}
inline void TargetData::set_max_depth(double value) {
  _internal_set_max_depth(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.TargetData.max_depth)
}

// optional int32 max_range_index = 10;
inline bool TargetData::_internal_has_max_range_index() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TargetData::has_max_range_index() const {
  return _internal_has_max_range_index();
}
inline void TargetData::clear_max_range_index() {
  max_range_index_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t TargetData::_internal_max_range_index() const {
  return max_range_index_;
}
inline int32_t TargetData::max_range_index() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.TargetData.max_range_index)
  return _internal_max_range_index();
}
inline void TargetData::_internal_set_max_range_index(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  max_range_index_ = value;
}
inline void TargetData::set_max_range_index(int32_t value) {
  _internal_set_max_range_index(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.TargetData.max_range_index)
}

// -------------------------------------------------------------------

// Bin

// optional int32 hor_index = 1;
inline bool Bin::_internal_has_hor_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Bin::has_hor_index() const {
  return _internal_has_hor_index();
}
inline void Bin::clear_hor_index() {
  hor_index_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t Bin::_internal_hor_index() const {
  return hor_index_;
}
inline int32_t Bin::hor_index() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Bin.hor_index)
  return _internal_hor_index();
}
inline void Bin::_internal_set_hor_index(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  hor_index_ = value;
}
inline void Bin::set_hor_index(int32_t value) {
  _internal_set_hor_index(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.Bin.hor_index)
}

// optional int32 ver_index = 2;
inline bool Bin::_internal_has_ver_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Bin::has_ver_index() const {
  return _internal_has_ver_index();
}
inline void Bin::clear_ver_index() {
  ver_index_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Bin::_internal_ver_index() const {
  return ver_index_;
}
inline int32_t Bin::ver_index() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Bin.ver_index)
  return _internal_ver_index();
}
inline void Bin::_internal_set_ver_index(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  ver_index_ = value;
}
inline void Bin::set_ver_index(int32_t value) {
  _internal_set_ver_index(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.Bin.ver_index)
}

// optional int32 range_index = 3;
inline bool Bin::_internal_has_range_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Bin::has_range_index() const {
  return _internal_has_range_index();
}
inline void Bin::clear_range_index() {
  range_index_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Bin::_internal_range_index() const {
  return range_index_;
}
inline int32_t Bin::range_index() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Bin.range_index)
  return _internal_range_index();
}
inline void Bin::_internal_set_range_index(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  range_index_ = value;
}
inline void Bin::set_range_index(int32_t value) {
  _internal_set_range_index(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.Bin.range_index)
}

// optional float cross_range = 4;
inline bool Bin::_internal_has_cross_range() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Bin::has_cross_range() const {
  return _internal_has_cross_range();
}
inline void Bin::clear_cross_range() {
  cross_range_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Bin::_internal_cross_range() const {
  return cross_range_;
}
inline float Bin::cross_range() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Bin.cross_range)
  return _internal_cross_range();
}
inline void Bin::_internal_set_cross_range(float value) {
  _has_bits_[0] |= 0x00000008u;
  cross_range_ = value;
}
inline void Bin::set_cross_range(float value) {
  _internal_set_cross_range(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.Bin.cross_range)
}

// optional float down_range = 5;
inline bool Bin::_internal_has_down_range() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Bin::has_down_range() const {
  return _internal_has_down_range();
}
inline void Bin::clear_down_range() {
  down_range_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Bin::_internal_down_range() const {
  return down_range_;
}
inline float Bin::down_range() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Bin.down_range)
  return _internal_down_range();
}
inline void Bin::_internal_set_down_range(float value) {
  _has_bits_[0] |= 0x00000010u;
  down_range_ = value;
}
inline void Bin::set_down_range(float value) {
  _internal_set_down_range(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.Bin.down_range)
}

// optional float depth = 6;
inline bool Bin::_internal_has_depth() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Bin::has_depth() const {
  return _internal_has_depth();
}
inline void Bin::clear_depth() {
  depth_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Bin::_internal_depth() const {
  return depth_;
}
inline float Bin::depth() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Bin.depth)
  return _internal_depth();
}
inline void Bin::_internal_set_depth(float value) {
  _has_bits_[0] |= 0x00000020u;
  depth_ = value;
}
inline void Bin::set_depth(float value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.Bin.depth)
}

// optional float strength = 7;
inline bool Bin::_internal_has_strength() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Bin::has_strength() const {
  return _internal_has_strength();
}
inline void Bin::clear_strength() {
  strength_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Bin::_internal_strength() const {
  return strength_;
}
inline float Bin::strength() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Bin.strength)
  return _internal_strength();
}
inline void Bin::_internal_set_strength(float value) {
  _has_bits_[0] |= 0x00000040u;
  strength_ = value;
}
inline void Bin::set_strength(float value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.Bin.strength)
}

// optional float confidence = 8;
inline bool Bin::_internal_has_confidence() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Bin::has_confidence() const {
  return _internal_has_confidence();
}
inline void Bin::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Bin::_internal_confidence() const {
  return confidence_;
}
inline float Bin::confidence() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Bin.confidence)
  return _internal_confidence();
}
inline void Bin::_internal_set_confidence(float value) {
  _has_bits_[0] |= 0x00000080u;
  confidence_ = value;
}
inline void Bin::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.Bin.confidence)
}

// -------------------------------------------------------------------

// Group

// repeated .proto.nav_api.Bin bins = 1;
inline int Group::_internal_bins_size() const {
  return bins_.size();
}
inline int Group::bins_size() const {
  return _internal_bins_size();
}
inline void Group::clear_bins() {
  bins_.Clear();
}
inline ::proto::nav_api::Bin* Group::mutable_bins(int index) {
  // @@protoc_insertion_point(field_mutable:proto.nav_api.Group.bins)
  return bins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin >*
Group::mutable_bins() {
  // @@protoc_insertion_point(field_mutable_list:proto.nav_api.Group.bins)
  return &bins_;
}
inline const ::proto::nav_api::Bin& Group::_internal_bins(int index) const {
  return bins_.Get(index);
}
inline const ::proto::nav_api::Bin& Group::bins(int index) const {
  // @@protoc_insertion_point(field_get:proto.nav_api.Group.bins)
  return _internal_bins(index);
}
inline ::proto::nav_api::Bin* Group::_internal_add_bins() {
  return bins_.Add();
}
inline ::proto::nav_api::Bin* Group::add_bins() {
  ::proto::nav_api::Bin* _add = _internal_add_bins();
  // @@protoc_insertion_point(field_add:proto.nav_api.Group.bins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::nav_api::Bin >&
Group::bins() const {
  // @@protoc_insertion_point(field_list:proto.nav_api.Group.bins)
  return bins_;
}

// -------------------------------------------------------------------

// ProcessorSettings

// optional .proto.time.Time time = 1;
inline bool ProcessorSettings::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool ProcessorSettings::has_time() const {
  return _internal_has_time();
}
inline const ::proto::time::Time& ProcessorSettings::_internal_time() const {
  const ::proto::time::Time* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::time::Time&>(
      ::proto::time::_Time_default_instance_);
}
inline const ::proto::time::Time& ProcessorSettings::time() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.ProcessorSettings.time)
  return _internal_time();
}
inline void ProcessorSettings::unsafe_arena_set_allocated_time(
    ::proto::time::Time* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.ProcessorSettings.time)
}
inline ::proto::time::Time* ProcessorSettings::release_time() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::time::Time* ProcessorSettings::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:proto.nav_api.ProcessorSettings.time)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::time::Time* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::proto::time::Time* ProcessorSettings::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000001u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::time::Time>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::proto::time::Time* ProcessorSettings::mutable_time() {
  ::proto::time::Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.ProcessorSettings.time)
  return _msg;
}
inline void ProcessorSettings::set_allocated_time(::proto::time::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.ProcessorSettings.time)
}

// optional float min_inwater_squelch = 2;
inline bool ProcessorSettings::_internal_has_min_inwater_squelch() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProcessorSettings::has_min_inwater_squelch() const {
  return _internal_has_min_inwater_squelch();
}
inline void ProcessorSettings::clear_min_inwater_squelch() {
  min_inwater_squelch_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ProcessorSettings::_internal_min_inwater_squelch() const {
  return min_inwater_squelch_;
}
inline float ProcessorSettings::min_inwater_squelch() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.ProcessorSettings.min_inwater_squelch)
  return _internal_min_inwater_squelch();
}
inline void ProcessorSettings::_internal_set_min_inwater_squelch(float value) {
  _has_bits_[0] |= 0x00000002u;
  min_inwater_squelch_ = value;
}
inline void ProcessorSettings::set_min_inwater_squelch(float value) {
  _internal_set_min_inwater_squelch(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.ProcessorSettings.min_inwater_squelch)
}

// optional float max_inwater_squelch = 3;
inline bool ProcessorSettings::_internal_has_max_inwater_squelch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProcessorSettings::has_max_inwater_squelch() const {
  return _internal_has_max_inwater_squelch();
}
inline void ProcessorSettings::clear_max_inwater_squelch() {
  max_inwater_squelch_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ProcessorSettings::_internal_max_inwater_squelch() const {
  return max_inwater_squelch_;
}
inline float ProcessorSettings::max_inwater_squelch() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.ProcessorSettings.max_inwater_squelch)
  return _internal_max_inwater_squelch();
}
inline void ProcessorSettings::_internal_set_max_inwater_squelch(float value) {
  _has_bits_[0] |= 0x00000004u;
  max_inwater_squelch_ = value;
}
inline void ProcessorSettings::set_max_inwater_squelch(float value) {
  _internal_set_max_inwater_squelch(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.ProcessorSettings.max_inwater_squelch)
}

// optional float inwater_squelch = 4;
inline bool ProcessorSettings::_internal_has_inwater_squelch() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ProcessorSettings::has_inwater_squelch() const {
  return _internal_has_inwater_squelch();
}
inline void ProcessorSettings::clear_inwater_squelch() {
  inwater_squelch_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ProcessorSettings::_internal_inwater_squelch() const {
  return inwater_squelch_;
}
inline float ProcessorSettings::inwater_squelch() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.ProcessorSettings.inwater_squelch)
  return _internal_inwater_squelch();
}
inline void ProcessorSettings::_internal_set_inwater_squelch(float value) {
  _has_bits_[0] |= 0x00000008u;
  inwater_squelch_ = value;
}
inline void ProcessorSettings::set_inwater_squelch(float value) {
  _internal_set_inwater_squelch(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.ProcessorSettings.inwater_squelch)
}

// optional bool squelchless_inwater_detector = 5;
inline bool ProcessorSettings::_internal_has_squelchless_inwater_detector() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ProcessorSettings::has_squelchless_inwater_detector() const {
  return _internal_has_squelchless_inwater_detector();
}
inline void ProcessorSettings::clear_squelchless_inwater_detector() {
  squelchless_inwater_detector_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ProcessorSettings::_internal_squelchless_inwater_detector() const {
  return squelchless_inwater_detector_;
}
inline bool ProcessorSettings::squelchless_inwater_detector() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.ProcessorSettings.squelchless_inwater_detector)
  return _internal_squelchless_inwater_detector();
}
inline void ProcessorSettings::_internal_set_squelchless_inwater_detector(bool value) {
  _has_bits_[0] |= 0x00000010u;
  squelchless_inwater_detector_ = value;
}
inline void ProcessorSettings::set_squelchless_inwater_detector(bool value) {
  _internal_set_squelchless_inwater_detector(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.ProcessorSettings.squelchless_inwater_detector)
}

// optional bool detect_bottom = 6;
inline bool ProcessorSettings::_internal_has_detect_bottom() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ProcessorSettings::has_detect_bottom() const {
  return _internal_has_detect_bottom();
}
inline void ProcessorSettings::clear_detect_bottom() {
  detect_bottom_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ProcessorSettings::_internal_detect_bottom() const {
  return detect_bottom_;
}
inline bool ProcessorSettings::detect_bottom() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.ProcessorSettings.detect_bottom)
  return _internal_detect_bottom();
}
inline void ProcessorSettings::_internal_set_detect_bottom(bool value) {
  _has_bits_[0] |= 0x00000020u;
  detect_bottom_ = value;
}
inline void ProcessorSettings::set_detect_bottom(bool value) {
  _internal_set_detect_bottom(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.ProcessorSettings.detect_bottom)
}

// optional .proto.nav_api.ProcessorSettings.SystemType system_type = 7 [default = kFS3DT];
inline bool ProcessorSettings::_internal_has_system_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ProcessorSettings::has_system_type() const {
  return _internal_has_system_type();
}
inline void ProcessorSettings::clear_system_type() {
  system_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::proto::nav_api::ProcessorSettings_SystemType ProcessorSettings::_internal_system_type() const {
  return static_cast< ::proto::nav_api::ProcessorSettings_SystemType >(system_type_);
}
inline ::proto::nav_api::ProcessorSettings_SystemType ProcessorSettings::system_type() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.ProcessorSettings.system_type)
  return _internal_system_type();
}
inline void ProcessorSettings::_internal_set_system_type(::proto::nav_api::ProcessorSettings_SystemType value) {
  assert(::proto::nav_api::ProcessorSettings_SystemType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  system_type_ = value;
}
inline void ProcessorSettings::set_system_type(::proto::nav_api::ProcessorSettings_SystemType value) {
  _internal_set_system_type(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.ProcessorSettings.system_type)
}

// optional .proto.nav_api.FieldOfView fov = 8 [default = k90d330m];
inline bool ProcessorSettings::_internal_has_fov() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ProcessorSettings::has_fov() const {
  return _internal_has_fov();
}
inline void ProcessorSettings::clear_fov() {
  fov_ = 2;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::proto::nav_api::FieldOfView ProcessorSettings::_internal_fov() const {
  return static_cast< ::proto::nav_api::FieldOfView >(fov_);
}
inline ::proto::nav_api::FieldOfView ProcessorSettings::fov() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.ProcessorSettings.fov)
  return _internal_fov();
}
inline void ProcessorSettings::_internal_set_fov(::proto::nav_api::FieldOfView value) {
  assert(::proto::nav_api::FieldOfView_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  fov_ = value;
}
inline void ProcessorSettings::set_fov(::proto::nav_api::FieldOfView value) {
  _internal_set_fov(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.ProcessorSettings.fov)
}

// -------------------------------------------------------------------

// GetProcessorSettingsRequest

// -------------------------------------------------------------------

// GetProcessorSettingsResponse

// optional .proto.nav_api.RequestResult result = 1;
inline bool GetProcessorSettingsResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool GetProcessorSettingsResponse::has_result() const {
  return _internal_has_result();
}
inline void GetProcessorSettingsResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::nav_api::RequestResult& GetProcessorSettingsResponse::_internal_result() const {
  const ::proto::nav_api::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::RequestResult&>(
      ::proto::nav_api::_RequestResult_default_instance_);
}
inline const ::proto::nav_api::RequestResult& GetProcessorSettingsResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.GetProcessorSettingsResponse.result)
  return _internal_result();
}
inline void GetProcessorSettingsResponse::unsafe_arena_set_allocated_result(
    ::proto::nav_api::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.GetProcessorSettingsResponse.result)
}
inline ::proto::nav_api::RequestResult* GetProcessorSettingsResponse::release_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::RequestResult* GetProcessorSettingsResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:proto.nav_api.GetProcessorSettingsResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::proto::nav_api::RequestResult* GetProcessorSettingsResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::proto::nav_api::RequestResult* GetProcessorSettingsResponse::mutable_result() {
  ::proto::nav_api::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.GetProcessorSettingsResponse.result)
  return _msg;
}
inline void GetProcessorSettingsResponse::set_allocated_result(::proto::nav_api::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.GetProcessorSettingsResponse.result)
}

// optional .proto.nav_api.ProcessorSettings settings = 2;
inline bool GetProcessorSettingsResponse::_internal_has_settings() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || settings_ != nullptr);
  return value;
}
inline bool GetProcessorSettingsResponse::has_settings() const {
  return _internal_has_settings();
}
inline void GetProcessorSettingsResponse::clear_settings() {
  if (settings_ != nullptr) settings_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::nav_api::ProcessorSettings& GetProcessorSettingsResponse::_internal_settings() const {
  const ::proto::nav_api::ProcessorSettings* p = settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::ProcessorSettings&>(
      ::proto::nav_api::_ProcessorSettings_default_instance_);
}
inline const ::proto::nav_api::ProcessorSettings& GetProcessorSettingsResponse::settings() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.GetProcessorSettingsResponse.settings)
  return _internal_settings();
}
inline void GetProcessorSettingsResponse::unsafe_arena_set_allocated_settings(
    ::proto::nav_api::ProcessorSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings_);
  }
  settings_ = settings;
  if (settings) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.GetProcessorSettingsResponse.settings)
}
inline ::proto::nav_api::ProcessorSettings* GetProcessorSettingsResponse::release_settings() {
  _has_bits_[0] &= ~0x00000002u;
  ::proto::nav_api::ProcessorSettings* temp = settings_;
  settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::ProcessorSettings* GetProcessorSettingsResponse::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:proto.nav_api.GetProcessorSettingsResponse.settings)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::nav_api::ProcessorSettings* temp = settings_;
  settings_ = nullptr;
  return temp;
}
inline ::proto::nav_api::ProcessorSettings* GetProcessorSettingsResponse::_internal_mutable_settings() {
  _has_bits_[0] |= 0x00000002u;
  if (settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::ProcessorSettings>(GetArenaForAllocation());
    settings_ = p;
  }
  return settings_;
}
inline ::proto::nav_api::ProcessorSettings* GetProcessorSettingsResponse::mutable_settings() {
  ::proto::nav_api::ProcessorSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.GetProcessorSettingsResponse.settings)
  return _msg;
}
inline void GetProcessorSettingsResponse::set_allocated_settings(::proto::nav_api::ProcessorSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::ProcessorSettings>::GetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.GetProcessorSettingsResponse.settings)
}

// -------------------------------------------------------------------

// SetFieldOfViewRequest

// optional .proto.nav_api.FieldOfView fov = 1;
inline bool SetFieldOfViewRequest::_internal_has_fov() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetFieldOfViewRequest::has_fov() const {
  return _internal_has_fov();
}
inline void SetFieldOfViewRequest::clear_fov() {
  fov_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::nav_api::FieldOfView SetFieldOfViewRequest::_internal_fov() const {
  return static_cast< ::proto::nav_api::FieldOfView >(fov_);
}
inline ::proto::nav_api::FieldOfView SetFieldOfViewRequest::fov() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetFieldOfViewRequest.fov)
  return _internal_fov();
}
inline void SetFieldOfViewRequest::_internal_set_fov(::proto::nav_api::FieldOfView value) {
  assert(::proto::nav_api::FieldOfView_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  fov_ = value;
}
inline void SetFieldOfViewRequest::set_fov(::proto::nav_api::FieldOfView value) {
  _internal_set_fov(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.SetFieldOfViewRequest.fov)
}

// -------------------------------------------------------------------

// SetFieldOfViewResponse

// optional .proto.nav_api.RequestResult result = 1;
inline bool SetFieldOfViewResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool SetFieldOfViewResponse::has_result() const {
  return _internal_has_result();
}
inline void SetFieldOfViewResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::nav_api::RequestResult& SetFieldOfViewResponse::_internal_result() const {
  const ::proto::nav_api::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::RequestResult&>(
      ::proto::nav_api::_RequestResult_default_instance_);
}
inline const ::proto::nav_api::RequestResult& SetFieldOfViewResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetFieldOfViewResponse.result)
  return _internal_result();
}
inline void SetFieldOfViewResponse::unsafe_arena_set_allocated_result(
    ::proto::nav_api::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.SetFieldOfViewResponse.result)
}
inline ::proto::nav_api::RequestResult* SetFieldOfViewResponse::release_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::RequestResult* SetFieldOfViewResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:proto.nav_api.SetFieldOfViewResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::proto::nav_api::RequestResult* SetFieldOfViewResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::proto::nav_api::RequestResult* SetFieldOfViewResponse::mutable_result() {
  ::proto::nav_api::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.SetFieldOfViewResponse.result)
  return _msg;
}
inline void SetFieldOfViewResponse::set_allocated_result(::proto::nav_api::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.SetFieldOfViewResponse.result)
}

// -------------------------------------------------------------------

// SetBottomDetectionRequest

// optional bool enable_bottom_detection = 1;
inline bool SetBottomDetectionRequest::_internal_has_enable_bottom_detection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetBottomDetectionRequest::has_enable_bottom_detection() const {
  return _internal_has_enable_bottom_detection();
}
inline void SetBottomDetectionRequest::clear_enable_bottom_detection() {
  enable_bottom_detection_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SetBottomDetectionRequest::_internal_enable_bottom_detection() const {
  return enable_bottom_detection_;
}
inline bool SetBottomDetectionRequest::enable_bottom_detection() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetBottomDetectionRequest.enable_bottom_detection)
  return _internal_enable_bottom_detection();
}
inline void SetBottomDetectionRequest::_internal_set_enable_bottom_detection(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_bottom_detection_ = value;
}
inline void SetBottomDetectionRequest::set_enable_bottom_detection(bool value) {
  _internal_set_enable_bottom_detection(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.SetBottomDetectionRequest.enable_bottom_detection)
}

// -------------------------------------------------------------------

// SetBottomDetectionResponse

// optional .proto.nav_api.RequestResult result = 1;
inline bool SetBottomDetectionResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool SetBottomDetectionResponse::has_result() const {
  return _internal_has_result();
}
inline void SetBottomDetectionResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::nav_api::RequestResult& SetBottomDetectionResponse::_internal_result() const {
  const ::proto::nav_api::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::RequestResult&>(
      ::proto::nav_api::_RequestResult_default_instance_);
}
inline const ::proto::nav_api::RequestResult& SetBottomDetectionResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetBottomDetectionResponse.result)
  return _internal_result();
}
inline void SetBottomDetectionResponse::unsafe_arena_set_allocated_result(
    ::proto::nav_api::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.SetBottomDetectionResponse.result)
}
inline ::proto::nav_api::RequestResult* SetBottomDetectionResponse::release_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::RequestResult* SetBottomDetectionResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:proto.nav_api.SetBottomDetectionResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::proto::nav_api::RequestResult* SetBottomDetectionResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::proto::nav_api::RequestResult* SetBottomDetectionResponse::mutable_result() {
  ::proto::nav_api::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.SetBottomDetectionResponse.result)
  return _msg;
}
inline void SetBottomDetectionResponse::set_allocated_result(::proto::nav_api::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.SetBottomDetectionResponse.result)
}

// -------------------------------------------------------------------

// SetInWaterSquelchRequest

// optional float new_squelch_val = 1;
inline bool SetInWaterSquelchRequest::_internal_has_new_squelch_val() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetInWaterSquelchRequest::has_new_squelch_val() const {
  return _internal_has_new_squelch_val();
}
inline void SetInWaterSquelchRequest::clear_new_squelch_val() {
  new_squelch_val_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SetInWaterSquelchRequest::_internal_new_squelch_val() const {
  return new_squelch_val_;
}
inline float SetInWaterSquelchRequest::new_squelch_val() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetInWaterSquelchRequest.new_squelch_val)
  return _internal_new_squelch_val();
}
inline void SetInWaterSquelchRequest::_internal_set_new_squelch_val(float value) {
  _has_bits_[0] |= 0x00000001u;
  new_squelch_val_ = value;
}
inline void SetInWaterSquelchRequest::set_new_squelch_val(float value) {
  _internal_set_new_squelch_val(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.SetInWaterSquelchRequest.new_squelch_val)
}

// -------------------------------------------------------------------

// SetInWaterSquelchResponse

// optional .proto.nav_api.RequestResult result = 1;
inline bool SetInWaterSquelchResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool SetInWaterSquelchResponse::has_result() const {
  return _internal_has_result();
}
inline void SetInWaterSquelchResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::nav_api::RequestResult& SetInWaterSquelchResponse::_internal_result() const {
  const ::proto::nav_api::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::RequestResult&>(
      ::proto::nav_api::_RequestResult_default_instance_);
}
inline const ::proto::nav_api::RequestResult& SetInWaterSquelchResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetInWaterSquelchResponse.result)
  return _internal_result();
}
inline void SetInWaterSquelchResponse::unsafe_arena_set_allocated_result(
    ::proto::nav_api::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.SetInWaterSquelchResponse.result)
}
inline ::proto::nav_api::RequestResult* SetInWaterSquelchResponse::release_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::RequestResult* SetInWaterSquelchResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:proto.nav_api.SetInWaterSquelchResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::proto::nav_api::RequestResult* SetInWaterSquelchResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::proto::nav_api::RequestResult* SetInWaterSquelchResponse::mutable_result() {
  ::proto::nav_api::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.SetInWaterSquelchResponse.result)
  return _msg;
}
inline void SetInWaterSquelchResponse::set_allocated_result(::proto::nav_api::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.SetInWaterSquelchResponse.result)
}

// -------------------------------------------------------------------

// SetSquelchlessInWaterDetectorRequest

// optional bool enable_squelchless_detection = 1;
inline bool SetSquelchlessInWaterDetectorRequest::_internal_has_enable_squelchless_detection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetSquelchlessInWaterDetectorRequest::has_enable_squelchless_detection() const {
  return _internal_has_enable_squelchless_detection();
}
inline void SetSquelchlessInWaterDetectorRequest::clear_enable_squelchless_detection() {
  enable_squelchless_detection_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SetSquelchlessInWaterDetectorRequest::_internal_enable_squelchless_detection() const {
  return enable_squelchless_detection_;
}
inline bool SetSquelchlessInWaterDetectorRequest::enable_squelchless_detection() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetSquelchlessInWaterDetectorRequest.enable_squelchless_detection)
  return _internal_enable_squelchless_detection();
}
inline void SetSquelchlessInWaterDetectorRequest::_internal_set_enable_squelchless_detection(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_squelchless_detection_ = value;
}
inline void SetSquelchlessInWaterDetectorRequest::set_enable_squelchless_detection(bool value) {
  _internal_set_enable_squelchless_detection(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.SetSquelchlessInWaterDetectorRequest.enable_squelchless_detection)
}

// -------------------------------------------------------------------

// SetSquelchlessInWaterDetectorResponse

// optional .proto.nav_api.RequestResult result = 1;
inline bool SetSquelchlessInWaterDetectorResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool SetSquelchlessInWaterDetectorResponse::has_result() const {
  return _internal_has_result();
}
inline void SetSquelchlessInWaterDetectorResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::nav_api::RequestResult& SetSquelchlessInWaterDetectorResponse::_internal_result() const {
  const ::proto::nav_api::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::RequestResult&>(
      ::proto::nav_api::_RequestResult_default_instance_);
}
inline const ::proto::nav_api::RequestResult& SetSquelchlessInWaterDetectorResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetSquelchlessInWaterDetectorResponse.result)
  return _internal_result();
}
inline void SetSquelchlessInWaterDetectorResponse::unsafe_arena_set_allocated_result(
    ::proto::nav_api::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.SetSquelchlessInWaterDetectorResponse.result)
}
inline ::proto::nav_api::RequestResult* SetSquelchlessInWaterDetectorResponse::release_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::RequestResult* SetSquelchlessInWaterDetectorResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:proto.nav_api.SetSquelchlessInWaterDetectorResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::proto::nav_api::RequestResult* SetSquelchlessInWaterDetectorResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::proto::nav_api::RequestResult* SetSquelchlessInWaterDetectorResponse::mutable_result() {
  ::proto::nav_api::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.SetSquelchlessInWaterDetectorResponse.result)
  return _msg;
}
inline void SetSquelchlessInWaterDetectorResponse::set_allocated_result(::proto::nav_api::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.SetSquelchlessInWaterDetectorResponse.result)
}

// -------------------------------------------------------------------

// VesselInfo

// optional float draft = 1;
inline bool VesselInfo::_internal_has_draft() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VesselInfo::has_draft() const {
  return _internal_has_draft();
}
inline void VesselInfo::clear_draft() {
  draft_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float VesselInfo::_internal_draft() const {
  return draft_;
}
inline float VesselInfo::draft() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.VesselInfo.draft)
  return _internal_draft();
}
inline void VesselInfo::_internal_set_draft(float value) {
  _has_bits_[0] |= 0x00000001u;
  draft_ = value;
}
inline void VesselInfo::set_draft(float value) {
  _internal_set_draft(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.VesselInfo.draft)
}

// optional float keel_offset = 2;
inline bool VesselInfo::_internal_has_keel_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VesselInfo::has_keel_offset() const {
  return _internal_has_keel_offset();
}
inline void VesselInfo::clear_keel_offset() {
  keel_offset_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float VesselInfo::_internal_keel_offset() const {
  return keel_offset_;
}
inline float VesselInfo::keel_offset() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.VesselInfo.keel_offset)
  return _internal_keel_offset();
}
inline void VesselInfo::_internal_set_keel_offset(float value) {
  _has_bits_[0] |= 0x00000002u;
  keel_offset_ = value;
}
inline void VesselInfo::set_keel_offset(float value) {
  _internal_set_keel_offset(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.VesselInfo.keel_offset)
}

// -------------------------------------------------------------------

// GetVesselInfoRequest

// -------------------------------------------------------------------

// GetVesselInfoResponse

// optional .proto.nav_api.RequestResult result = 1;
inline bool GetVesselInfoResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool GetVesselInfoResponse::has_result() const {
  return _internal_has_result();
}
inline void GetVesselInfoResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::nav_api::RequestResult& GetVesselInfoResponse::_internal_result() const {
  const ::proto::nav_api::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::RequestResult&>(
      ::proto::nav_api::_RequestResult_default_instance_);
}
inline const ::proto::nav_api::RequestResult& GetVesselInfoResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.GetVesselInfoResponse.result)
  return _internal_result();
}
inline void GetVesselInfoResponse::unsafe_arena_set_allocated_result(
    ::proto::nav_api::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.GetVesselInfoResponse.result)
}
inline ::proto::nav_api::RequestResult* GetVesselInfoResponse::release_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::RequestResult* GetVesselInfoResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:proto.nav_api.GetVesselInfoResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::proto::nav_api::RequestResult* GetVesselInfoResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::proto::nav_api::RequestResult* GetVesselInfoResponse::mutable_result() {
  ::proto::nav_api::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.GetVesselInfoResponse.result)
  return _msg;
}
inline void GetVesselInfoResponse::set_allocated_result(::proto::nav_api::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.GetVesselInfoResponse.result)
}

// optional .proto.nav_api.VesselInfo info = 2;
inline bool GetVesselInfoResponse::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool GetVesselInfoResponse::has_info() const {
  return _internal_has_info();
}
inline void GetVesselInfoResponse::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::nav_api::VesselInfo& GetVesselInfoResponse::_internal_info() const {
  const ::proto::nav_api::VesselInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::VesselInfo&>(
      ::proto::nav_api::_VesselInfo_default_instance_);
}
inline const ::proto::nav_api::VesselInfo& GetVesselInfoResponse::info() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.GetVesselInfoResponse.info)
  return _internal_info();
}
inline void GetVesselInfoResponse::unsafe_arena_set_allocated_info(
    ::proto::nav_api::VesselInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.GetVesselInfoResponse.info)
}
inline ::proto::nav_api::VesselInfo* GetVesselInfoResponse::release_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::proto::nav_api::VesselInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::VesselInfo* GetVesselInfoResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:proto.nav_api.GetVesselInfoResponse.info)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::nav_api::VesselInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::proto::nav_api::VesselInfo* GetVesselInfoResponse::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000002u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::VesselInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::proto::nav_api::VesselInfo* GetVesselInfoResponse::mutable_info() {
  ::proto::nav_api::VesselInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.GetVesselInfoResponse.info)
  return _msg;
}
inline void GetVesselInfoResponse::set_allocated_info(::proto::nav_api::VesselInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::VesselInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.GetVesselInfoResponse.info)
}

// -------------------------------------------------------------------

// SetDraftRequest

// optional float new_draft = 1;
inline bool SetDraftRequest::_internal_has_new_draft() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetDraftRequest::has_new_draft() const {
  return _internal_has_new_draft();
}
inline void SetDraftRequest::clear_new_draft() {
  new_draft_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SetDraftRequest::_internal_new_draft() const {
  return new_draft_;
}
inline float SetDraftRequest::new_draft() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetDraftRequest.new_draft)
  return _internal_new_draft();
}
inline void SetDraftRequest::_internal_set_new_draft(float value) {
  _has_bits_[0] |= 0x00000001u;
  new_draft_ = value;
}
inline void SetDraftRequest::set_new_draft(float value) {
  _internal_set_new_draft(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.SetDraftRequest.new_draft)
}

// -------------------------------------------------------------------

// SetDraftResponse

// optional .proto.nav_api.RequestResult result = 1;
inline bool SetDraftResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool SetDraftResponse::has_result() const {
  return _internal_has_result();
}
inline void SetDraftResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::nav_api::RequestResult& SetDraftResponse::_internal_result() const {
  const ::proto::nav_api::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::RequestResult&>(
      ::proto::nav_api::_RequestResult_default_instance_);
}
inline const ::proto::nav_api::RequestResult& SetDraftResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetDraftResponse.result)
  return _internal_result();
}
inline void SetDraftResponse::unsafe_arena_set_allocated_result(
    ::proto::nav_api::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.SetDraftResponse.result)
}
inline ::proto::nav_api::RequestResult* SetDraftResponse::release_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::RequestResult* SetDraftResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:proto.nav_api.SetDraftResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::proto::nav_api::RequestResult* SetDraftResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::proto::nav_api::RequestResult* SetDraftResponse::mutable_result() {
  ::proto::nav_api::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.SetDraftResponse.result)
  return _msg;
}
inline void SetDraftResponse::set_allocated_result(::proto::nav_api::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.SetDraftResponse.result)
}

// -------------------------------------------------------------------

// SetKeelOffsetRequest

// optional float new_keel_offset = 1;
inline bool SetKeelOffsetRequest::_internal_has_new_keel_offset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetKeelOffsetRequest::has_new_keel_offset() const {
  return _internal_has_new_keel_offset();
}
inline void SetKeelOffsetRequest::clear_new_keel_offset() {
  new_keel_offset_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SetKeelOffsetRequest::_internal_new_keel_offset() const {
  return new_keel_offset_;
}
inline float SetKeelOffsetRequest::new_keel_offset() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetKeelOffsetRequest.new_keel_offset)
  return _internal_new_keel_offset();
}
inline void SetKeelOffsetRequest::_internal_set_new_keel_offset(float value) {
  _has_bits_[0] |= 0x00000001u;
  new_keel_offset_ = value;
}
inline void SetKeelOffsetRequest::set_new_keel_offset(float value) {
  _internal_set_new_keel_offset(value);
  // @@protoc_insertion_point(field_set:proto.nav_api.SetKeelOffsetRequest.new_keel_offset)
}

// -------------------------------------------------------------------

// SetKeelOffsetResponse

// optional .proto.nav_api.RequestResult result = 1;
inline bool SetKeelOffsetResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool SetKeelOffsetResponse::has_result() const {
  return _internal_has_result();
}
inline void SetKeelOffsetResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::nav_api::RequestResult& SetKeelOffsetResponse::_internal_result() const {
  const ::proto::nav_api::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::nav_api::RequestResult&>(
      ::proto::nav_api::_RequestResult_default_instance_);
}
inline const ::proto::nav_api::RequestResult& SetKeelOffsetResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.nav_api.SetKeelOffsetResponse.result)
  return _internal_result();
}
inline void SetKeelOffsetResponse::unsafe_arena_set_allocated_result(
    ::proto::nav_api::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.nav_api.SetKeelOffsetResponse.result)
}
inline ::proto::nav_api::RequestResult* SetKeelOffsetResponse::release_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::nav_api::RequestResult* SetKeelOffsetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:proto.nav_api.SetKeelOffsetResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::nav_api::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::proto::nav_api::RequestResult* SetKeelOffsetResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::nav_api::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::proto::nav_api::RequestResult* SetKeelOffsetResponse::mutable_result() {
  ::proto::nav_api::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:proto.nav_api.SetKeelOffsetResponse.result)
  return _msg;
}
inline void SetKeelOffsetResponse::set_allocated_result(::proto::nav_api::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::nav_api::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:proto.nav_api.SetKeelOffsetResponse.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nav_api
}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::nav_api::RequestResult_ResultCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::nav_api::ProcessorSettings_SystemType> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::nav_api::FieldOfView> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_nav_5fapi_2eproto
